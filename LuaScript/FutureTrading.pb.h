// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: FutureTrading.proto

#ifndef PROTOBUF_FutureTrading_2eproto__INCLUDED
#define PROTOBUF_FutureTrading_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace FutureTradingPB {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_FutureTrading_2eproto();
void protobuf_AssignDesc_FutureTrading_2eproto();
void protobuf_ShutdownFile_FutureTrading_2eproto();

class Login;
class Error;
class InsertOrder;
class RtnInsertOrder;
class WaitInsertOrder;
class ReqBuffInfo;
class RtnTradedInfo;
class RtnAllTradedInfo;
class MThostFtdcOrderField;
class MThostFtdcTradeField;
class OrderAction;
class MThostFtdcQryInvestorPositionField;
class RtnMThostFtdcQryInvestorPositionField;
class MThostFtdcInvestorPositionField;
class MThostFtdcTradingAccountField;
class MThostFtdcQryTradingAccountField;
class ConRequest;
class ConResponse;
class MThostFtdcInstrumentField;

// ===================================================================

class Login : public ::google::protobuf::Message {
 public:
  Login();
  virtual ~Login();
  
  Login(const Login& from);
  
  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();
  
  void Swap(Login* other);
  
  // implements Message ----------------------------------------------
  
  Login* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string FrontAdd = 1;
  inline bool has_frontadd() const;
  inline void clear_frontadd();
  static const int kFrontAddFieldNumber = 1;
  inline const ::std::string& frontadd() const;
  inline void set_frontadd(const ::std::string& value);
  inline void set_frontadd(const char* value);
  inline void set_frontadd(const char* value, size_t size);
  inline ::std::string* mutable_frontadd();
  inline ::std::string* release_frontadd();
  
  // required string BrokerID = 2;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIDFieldNumber = 2;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string InvestorID = 3;
  inline bool has_investorid() const;
  inline void clear_investorid();
  static const int kInvestorIDFieldNumber = 3;
  inline const ::std::string& investorid() const;
  inline void set_investorid(const ::std::string& value);
  inline void set_investorid(const char* value);
  inline void set_investorid(const char* value, size_t size);
  inline ::std::string* mutable_investorid();
  inline ::std::string* release_investorid();
  
  // required string Password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.Login)
 private:
  inline void set_has_frontadd();
  inline void clear_has_frontadd();
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_investorid();
  inline void clear_has_investorid();
  inline void set_has_password();
  inline void clear_has_password();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* frontadd_;
  ::std::string* brokerid_;
  ::std::string* investorid_;
  ::std::string* password_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static Login* default_instance_;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message {
 public:
  Error();
  virtual ~Error();
  
  Error(const Error& from);
  
  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();
  
  void Swap(Error* other);
  
  // implements Message ----------------------------------------------
  
  Error* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 ErrorID = 1;
  inline bool has_errorid() const;
  inline void clear_errorid();
  static const int kErrorIDFieldNumber = 1;
  inline ::google::protobuf::int32 errorid() const;
  inline void set_errorid(::google::protobuf::int32 value);
  
  // required string ErrorMsg = 2;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrorMsgFieldNumber = 2;
  inline const ::std::string& errormsg() const;
  inline void set_errormsg(const ::std::string& value);
  inline void set_errormsg(const char* value);
  inline void set_errormsg(const char* value, size_t size);
  inline ::std::string* mutable_errormsg();
  inline ::std::string* release_errormsg();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.Error)
 private:
  inline void set_has_errorid();
  inline void clear_has_errorid();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* errormsg_;
  ::google::protobuf::int32 errorid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static Error* default_instance_;
};
// -------------------------------------------------------------------

class InsertOrder : public ::google::protobuf::Message {
 public:
  InsertOrder();
  virtual ~InsertOrder();
  
  InsertOrder(const InsertOrder& from);
  
  inline InsertOrder& operator=(const InsertOrder& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertOrder& default_instance();
  
  void Swap(InsertOrder* other);
  
  // implements Message ----------------------------------------------
  
  InsertOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InsertOrder& from);
  void MergeFrom(const InsertOrder& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 HandleID = 1;
  inline bool has_handleid() const;
  inline void clear_handleid();
  static const int kHandleIDFieldNumber = 1;
  inline ::google::protobuf::int32 handleid() const;
  inline void set_handleid(::google::protobuf::int32 value);
  
  // required string InstrumentID = 2;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 2;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  
  // required string ExchangeID = 3;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIDFieldNumber = 3;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // required double LimitPrice = 4;
  inline bool has_limitprice() const;
  inline void clear_limitprice();
  static const int kLimitPriceFieldNumber = 4;
  inline double limitprice() const;
  inline void set_limitprice(double value);
  
  // required int32 VolumeTotalOriginal = 5;
  inline bool has_volumetotaloriginal() const;
  inline void clear_volumetotaloriginal();
  static const int kVolumeTotalOriginalFieldNumber = 5;
  inline ::google::protobuf::int32 volumetotaloriginal() const;
  inline void set_volumetotaloriginal(::google::protobuf::int32 value);
  
  // required string Direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  
  // required string CombOffsetFlag = 7;
  inline bool has_comboffsetflag() const;
  inline void clear_comboffsetflag();
  static const int kCombOffsetFlagFieldNumber = 7;
  inline const ::std::string& comboffsetflag() const;
  inline void set_comboffsetflag(const ::std::string& value);
  inline void set_comboffsetflag(const char* value);
  inline void set_comboffsetflag(const char* value, size_t size);
  inline ::std::string* mutable_comboffsetflag();
  inline ::std::string* release_comboffsetflag();
  
  // required string OrderPriceType = 8;
  inline bool has_orderpricetype() const;
  inline void clear_orderpricetype();
  static const int kOrderPriceTypeFieldNumber = 8;
  inline const ::std::string& orderpricetype() const;
  inline void set_orderpricetype(const ::std::string& value);
  inline void set_orderpricetype(const char* value);
  inline void set_orderpricetype(const char* value, size_t size);
  inline ::std::string* mutable_orderpricetype();
  inline ::std::string* release_orderpricetype();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.InsertOrder)
 private:
  inline void set_has_handleid();
  inline void clear_has_handleid();
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  inline void set_has_limitprice();
  inline void clear_has_limitprice();
  inline void set_has_volumetotaloriginal();
  inline void clear_has_volumetotaloriginal();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_comboffsetflag();
  inline void clear_has_comboffsetflag();
  inline void set_has_orderpricetype();
  inline void clear_has_orderpricetype();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrumentid_;
  ::std::string* exchangeid_;
  ::google::protobuf::int32 handleid_;
  ::google::protobuf::int32 volumetotaloriginal_;
  double limitprice_;
  ::std::string* direction_;
  ::std::string* comboffsetflag_;
  ::std::string* orderpricetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static InsertOrder* default_instance_;
};
// -------------------------------------------------------------------

class RtnInsertOrder : public ::google::protobuf::Message {
 public:
  RtnInsertOrder();
  virtual ~RtnInsertOrder();
  
  RtnInsertOrder(const RtnInsertOrder& from);
  
  inline RtnInsertOrder& operator=(const RtnInsertOrder& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtnInsertOrder& default_instance();
  
  void Swap(RtnInsertOrder* other);
  
  // implements Message ----------------------------------------------
  
  RtnInsertOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtnInsertOrder& from);
  void MergeFrom(const RtnInsertOrder& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 HandleID = 1;
  inline bool has_handleid() const;
  inline void clear_handleid();
  static const int kHandleIDFieldNumber = 1;
  inline ::google::protobuf::int32 handleid() const;
  inline void set_handleid(::google::protobuf::int32 value);
  
  // required int32 Ref = 2;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 2;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);
  
  // required int32 FrontID = 3;
  inline bool has_frontid() const;
  inline void clear_frontid();
  static const int kFrontIDFieldNumber = 3;
  inline ::google::protobuf::int32 frontid() const;
  inline void set_frontid(::google::protobuf::int32 value);
  
  // required int32 SessionID = 4;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 4;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);
  
  // repeated .FutureTradingPB.MThostFtdcOrderField LastOrder = 5;
  inline int lastorder_size() const;
  inline void clear_lastorder();
  static const int kLastOrderFieldNumber = 5;
  inline const ::FutureTradingPB::MThostFtdcOrderField& lastorder(int index) const;
  inline ::FutureTradingPB::MThostFtdcOrderField* mutable_lastorder(int index);
  inline ::FutureTradingPB::MThostFtdcOrderField* add_lastorder();
  inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >&
      lastorder() const;
  inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >*
      mutable_lastorder();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.RtnInsertOrder)
 private:
  inline void set_has_handleid();
  inline void clear_has_handleid();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_frontid();
  inline void clear_has_frontid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 handleid_;
  ::google::protobuf::int32 ref_;
  ::google::protobuf::int32 frontid_;
  ::google::protobuf::int32 sessionid_;
  ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField > lastorder_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static RtnInsertOrder* default_instance_;
};
// -------------------------------------------------------------------

class WaitInsertOrder : public ::google::protobuf::Message {
 public:
  WaitInsertOrder();
  virtual ~WaitInsertOrder();
  
  WaitInsertOrder(const WaitInsertOrder& from);
  
  inline WaitInsertOrder& operator=(const WaitInsertOrder& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitInsertOrder& default_instance();
  
  void Swap(WaitInsertOrder* other);
  
  // implements Message ----------------------------------------------
  
  WaitInsertOrder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WaitInsertOrder& from);
  void MergeFrom(const WaitInsertOrder& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 HandleID = 1;
  inline bool has_handleid() const;
  inline void clear_handleid();
  static const int kHandleIDFieldNumber = 1;
  inline ::google::protobuf::int32 handleid() const;
  inline void set_handleid(::google::protobuf::int32 value);
  
  // required int32 Ref = 2;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 2;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);
  
  // required int32 FrontID = 3;
  inline bool has_frontid() const;
  inline void clear_frontid();
  static const int kFrontIDFieldNumber = 3;
  inline ::google::protobuf::int32 frontid() const;
  inline void set_frontid(::google::protobuf::int32 value);
  
  // required int32 SessionID = 4;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 4;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.WaitInsertOrder)
 private:
  inline void set_has_handleid();
  inline void clear_has_handleid();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_frontid();
  inline void clear_has_frontid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 handleid_;
  ::google::protobuf::int32 ref_;
  ::google::protobuf::int32 frontid_;
  ::google::protobuf::int32 sessionid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static WaitInsertOrder* default_instance_;
};
// -------------------------------------------------------------------

class ReqBuffInfo : public ::google::protobuf::Message {
 public:
  ReqBuffInfo();
  virtual ~ReqBuffInfo();
  
  ReqBuffInfo(const ReqBuffInfo& from);
  
  inline ReqBuffInfo& operator=(const ReqBuffInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqBuffInfo& default_instance();
  
  void Swap(ReqBuffInfo* other);
  
  // implements Message ----------------------------------------------
  
  ReqBuffInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqBuffInfo& from);
  void MergeFrom(const ReqBuffInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 HandleID = 1;
  inline bool has_handleid() const;
  inline void clear_handleid();
  static const int kHandleIDFieldNumber = 1;
  inline ::google::protobuf::int32 handleid() const;
  inline void set_handleid(::google::protobuf::int32 value);
  
  // required int32 Ref = 2;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 2;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);
  
  // required int32 FrontID = 3;
  inline bool has_frontid() const;
  inline void clear_frontid();
  static const int kFrontIDFieldNumber = 3;
  inline ::google::protobuf::int32 frontid() const;
  inline void set_frontid(::google::protobuf::int32 value);
  
  // required int32 SessionID = 4;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 4;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.ReqBuffInfo)
 private:
  inline void set_has_handleid();
  inline void clear_has_handleid();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_frontid();
  inline void clear_has_frontid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 handleid_;
  ::google::protobuf::int32 ref_;
  ::google::protobuf::int32 frontid_;
  ::google::protobuf::int32 sessionid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static ReqBuffInfo* default_instance_;
};
// -------------------------------------------------------------------

class RtnTradedInfo : public ::google::protobuf::Message {
 public:
  RtnTradedInfo();
  virtual ~RtnTradedInfo();
  
  RtnTradedInfo(const RtnTradedInfo& from);
  
  inline RtnTradedInfo& operator=(const RtnTradedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtnTradedInfo& default_instance();
  
  void Swap(RtnTradedInfo* other);
  
  // implements Message ----------------------------------------------
  
  RtnTradedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtnTradedInfo& from);
  void MergeFrom(const RtnTradedInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 HandleID = 1;
  inline bool has_handleid() const;
  inline void clear_handleid();
  static const int kHandleIDFieldNumber = 1;
  inline ::google::protobuf::int32 handleid() const;
  inline void set_handleid(::google::protobuf::int32 value);
  
  // required int32 Ref = 2;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 2;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);
  
  // required int32 FrontID = 3;
  inline bool has_frontid() const;
  inline void clear_frontid();
  static const int kFrontIDFieldNumber = 3;
  inline ::google::protobuf::int32 frontid() const;
  inline void set_frontid(::google::protobuf::int32 value);
  
  // required int32 SessionID = 4;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 4;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);
  
  // repeated .FutureTradingPB.MThostFtdcOrderField LastOrder = 5;
  inline int lastorder_size() const;
  inline void clear_lastorder();
  static const int kLastOrderFieldNumber = 5;
  inline const ::FutureTradingPB::MThostFtdcOrderField& lastorder(int index) const;
  inline ::FutureTradingPB::MThostFtdcOrderField* mutable_lastorder(int index);
  inline ::FutureTradingPB::MThostFtdcOrderField* add_lastorder();
  inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >&
      lastorder() const;
  inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >*
      mutable_lastorder();
  
  // repeated .FutureTradingPB.MThostFtdcTradeField LastTrade = 6;
  inline int lasttrade_size() const;
  inline void clear_lasttrade();
  static const int kLastTradeFieldNumber = 6;
  inline const ::FutureTradingPB::MThostFtdcTradeField& lasttrade(int index) const;
  inline ::FutureTradingPB::MThostFtdcTradeField* mutable_lasttrade(int index);
  inline ::FutureTradingPB::MThostFtdcTradeField* add_lasttrade();
  inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcTradeField >&
      lasttrade() const;
  inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcTradeField >*
      mutable_lasttrade();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.RtnTradedInfo)
 private:
  inline void set_has_handleid();
  inline void clear_has_handleid();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_frontid();
  inline void clear_has_frontid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 handleid_;
  ::google::protobuf::int32 ref_;
  ::google::protobuf::int32 frontid_;
  ::google::protobuf::int32 sessionid_;
  ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField > lastorder_;
  ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcTradeField > lasttrade_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static RtnTradedInfo* default_instance_;
};
// -------------------------------------------------------------------

class RtnAllTradedInfo : public ::google::protobuf::Message {
 public:
  RtnAllTradedInfo();
  virtual ~RtnAllTradedInfo();
  
  RtnAllTradedInfo(const RtnAllTradedInfo& from);
  
  inline RtnAllTradedInfo& operator=(const RtnAllTradedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtnAllTradedInfo& default_instance();
  
  void Swap(RtnAllTradedInfo* other);
  
  // implements Message ----------------------------------------------
  
  RtnAllTradedInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtnAllTradedInfo& from);
  void MergeFrom(const RtnAllTradedInfo& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FutureTradingPB.RtnTradedInfo AllTradedInfo = 1;
  inline int alltradedinfo_size() const;
  inline void clear_alltradedinfo();
  static const int kAllTradedInfoFieldNumber = 1;
  inline const ::FutureTradingPB::RtnTradedInfo& alltradedinfo(int index) const;
  inline ::FutureTradingPB::RtnTradedInfo* mutable_alltradedinfo(int index);
  inline ::FutureTradingPB::RtnTradedInfo* add_alltradedinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::RtnTradedInfo >&
      alltradedinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::RtnTradedInfo >*
      mutable_alltradedinfo();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.RtnAllTradedInfo)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::RtnTradedInfo > alltradedinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static RtnAllTradedInfo* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcOrderField : public ::google::protobuf::Message {
 public:
  MThostFtdcOrderField();
  virtual ~MThostFtdcOrderField();
  
  MThostFtdcOrderField(const MThostFtdcOrderField& from);
  
  inline MThostFtdcOrderField& operator=(const MThostFtdcOrderField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcOrderField& default_instance();
  
  void Swap(MThostFtdcOrderField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcOrderField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcOrderField& from);
  void MergeFrom(const MThostFtdcOrderField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string InstrumentID = 1;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 1;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  
  // required string OrderRef = 2;
  inline bool has_orderref() const;
  inline void clear_orderref();
  static const int kOrderRefFieldNumber = 2;
  inline const ::std::string& orderref() const;
  inline void set_orderref(const ::std::string& value);
  inline void set_orderref(const char* value);
  inline void set_orderref(const char* value, size_t size);
  inline ::std::string* mutable_orderref();
  inline ::std::string* release_orderref();
  
  // required string OrderPriceType = 3;
  inline bool has_orderpricetype() const;
  inline void clear_orderpricetype();
  static const int kOrderPriceTypeFieldNumber = 3;
  inline const ::std::string& orderpricetype() const;
  inline void set_orderpricetype(const ::std::string& value);
  inline void set_orderpricetype(const char* value);
  inline void set_orderpricetype(const char* value, size_t size);
  inline ::std::string* mutable_orderpricetype();
  inline ::std::string* release_orderpricetype();
  
  // required string Direction = 4;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 4;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  
  // required string CombOffsetFlag = 5;
  inline bool has_comboffsetflag() const;
  inline void clear_comboffsetflag();
  static const int kCombOffsetFlagFieldNumber = 5;
  inline const ::std::string& comboffsetflag() const;
  inline void set_comboffsetflag(const ::std::string& value);
  inline void set_comboffsetflag(const char* value);
  inline void set_comboffsetflag(const char* value, size_t size);
  inline ::std::string* mutable_comboffsetflag();
  inline ::std::string* release_comboffsetflag();
  
  // required string CombHedgeFlag = 6;
  inline bool has_combhedgeflag() const;
  inline void clear_combhedgeflag();
  static const int kCombHedgeFlagFieldNumber = 6;
  inline const ::std::string& combhedgeflag() const;
  inline void set_combhedgeflag(const ::std::string& value);
  inline void set_combhedgeflag(const char* value);
  inline void set_combhedgeflag(const char* value, size_t size);
  inline ::std::string* mutable_combhedgeflag();
  inline ::std::string* release_combhedgeflag();
  
  // required double LimitPrice = 7;
  inline bool has_limitprice() const;
  inline void clear_limitprice();
  static const int kLimitPriceFieldNumber = 7;
  inline double limitprice() const;
  inline void set_limitprice(double value);
  
  // required int32 VolumeTotalOriginal = 8;
  inline bool has_volumetotaloriginal() const;
  inline void clear_volumetotaloriginal();
  static const int kVolumeTotalOriginalFieldNumber = 8;
  inline ::google::protobuf::int32 volumetotaloriginal() const;
  inline void set_volumetotaloriginal(::google::protobuf::int32 value);
  
  // required string TimeCondition = 9;
  inline bool has_timecondition() const;
  inline void clear_timecondition();
  static const int kTimeConditionFieldNumber = 9;
  inline const ::std::string& timecondition() const;
  inline void set_timecondition(const ::std::string& value);
  inline void set_timecondition(const char* value);
  inline void set_timecondition(const char* value, size_t size);
  inline ::std::string* mutable_timecondition();
  inline ::std::string* release_timecondition();
  
  // required string GTDDate = 10;
  inline bool has_gtddate() const;
  inline void clear_gtddate();
  static const int kGTDDateFieldNumber = 10;
  inline const ::std::string& gtddate() const;
  inline void set_gtddate(const ::std::string& value);
  inline void set_gtddate(const char* value);
  inline void set_gtddate(const char* value, size_t size);
  inline ::std::string* mutable_gtddate();
  inline ::std::string* release_gtddate();
  
  // required int32 RequestID = 11;
  inline bool has_requestid() const;
  inline void clear_requestid();
  static const int kRequestIDFieldNumber = 11;
  inline ::google::protobuf::int32 requestid() const;
  inline void set_requestid(::google::protobuf::int32 value);
  
  // required string OrderLocalID = 12;
  inline bool has_orderlocalid() const;
  inline void clear_orderlocalid();
  static const int kOrderLocalIDFieldNumber = 12;
  inline const ::std::string& orderlocalid() const;
  inline void set_orderlocalid(const ::std::string& value);
  inline void set_orderlocalid(const char* value);
  inline void set_orderlocalid(const char* value, size_t size);
  inline ::std::string* mutable_orderlocalid();
  inline ::std::string* release_orderlocalid();
  
  // required string ExchangeID = 13;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIDFieldNumber = 13;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // required string ExchangeInstID = 14;
  inline bool has_exchangeinstid() const;
  inline void clear_exchangeinstid();
  static const int kExchangeInstIDFieldNumber = 14;
  inline const ::std::string& exchangeinstid() const;
  inline void set_exchangeinstid(const ::std::string& value);
  inline void set_exchangeinstid(const char* value);
  inline void set_exchangeinstid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeinstid();
  inline ::std::string* release_exchangeinstid();
  
  // required string OrderSubmitStatus = 15;
  inline bool has_ordersubmitstatus() const;
  inline void clear_ordersubmitstatus();
  static const int kOrderSubmitStatusFieldNumber = 15;
  inline const ::std::string& ordersubmitstatus() const;
  inline void set_ordersubmitstatus(const ::std::string& value);
  inline void set_ordersubmitstatus(const char* value);
  inline void set_ordersubmitstatus(const char* value, size_t size);
  inline ::std::string* mutable_ordersubmitstatus();
  inline ::std::string* release_ordersubmitstatus();
  
  // required int32 NotifySequence = 16;
  inline bool has_notifysequence() const;
  inline void clear_notifysequence();
  static const int kNotifySequenceFieldNumber = 16;
  inline ::google::protobuf::int32 notifysequence() const;
  inline void set_notifysequence(::google::protobuf::int32 value);
  
  // required string TradingDay = 17;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingDayFieldNumber = 17;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  
  // required int32 SettlementID = 18;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementIDFieldNumber = 18;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);
  
  // required string OrderSysID = 19;
  inline bool has_ordersysid() const;
  inline void clear_ordersysid();
  static const int kOrderSysIDFieldNumber = 19;
  inline const ::std::string& ordersysid() const;
  inline void set_ordersysid(const ::std::string& value);
  inline void set_ordersysid(const char* value);
  inline void set_ordersysid(const char* value, size_t size);
  inline ::std::string* mutable_ordersysid();
  inline ::std::string* release_ordersysid();
  
  // required string OrderSource = 20;
  inline bool has_ordersource() const;
  inline void clear_ordersource();
  static const int kOrderSourceFieldNumber = 20;
  inline const ::std::string& ordersource() const;
  inline void set_ordersource(const ::std::string& value);
  inline void set_ordersource(const char* value);
  inline void set_ordersource(const char* value, size_t size);
  inline ::std::string* mutable_ordersource();
  inline ::std::string* release_ordersource();
  
  // required string OrderStatus = 21;
  inline bool has_orderstatus() const;
  inline void clear_orderstatus();
  static const int kOrderStatusFieldNumber = 21;
  inline const ::std::string& orderstatus() const;
  inline void set_orderstatus(const ::std::string& value);
  inline void set_orderstatus(const char* value);
  inline void set_orderstatus(const char* value, size_t size);
  inline ::std::string* mutable_orderstatus();
  inline ::std::string* release_orderstatus();
  
  // required string OrderType = 22;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 22;
  inline const ::std::string& ordertype() const;
  inline void set_ordertype(const ::std::string& value);
  inline void set_ordertype(const char* value);
  inline void set_ordertype(const char* value, size_t size);
  inline ::std::string* mutable_ordertype();
  inline ::std::string* release_ordertype();
  
  // required int32 VolumeTraded = 23;
  inline bool has_volumetraded() const;
  inline void clear_volumetraded();
  static const int kVolumeTradedFieldNumber = 23;
  inline ::google::protobuf::int32 volumetraded() const;
  inline void set_volumetraded(::google::protobuf::int32 value);
  
  // required int32 VolumeTotal = 24;
  inline bool has_volumetotal() const;
  inline void clear_volumetotal();
  static const int kVolumeTotalFieldNumber = 24;
  inline ::google::protobuf::int32 volumetotal() const;
  inline void set_volumetotal(::google::protobuf::int32 value);
  
  // required string InsertDate = 25;
  inline bool has_insertdate() const;
  inline void clear_insertdate();
  static const int kInsertDateFieldNumber = 25;
  inline const ::std::string& insertdate() const;
  inline void set_insertdate(const ::std::string& value);
  inline void set_insertdate(const char* value);
  inline void set_insertdate(const char* value, size_t size);
  inline ::std::string* mutable_insertdate();
  inline ::std::string* release_insertdate();
  
  // required string InsertTime = 26;
  inline bool has_inserttime() const;
  inline void clear_inserttime();
  static const int kInsertTimeFieldNumber = 26;
  inline const ::std::string& inserttime() const;
  inline void set_inserttime(const ::std::string& value);
  inline void set_inserttime(const char* value);
  inline void set_inserttime(const char* value, size_t size);
  inline ::std::string* mutable_inserttime();
  inline ::std::string* release_inserttime();
  
  // required string ActiveTime = 27;
  inline bool has_activetime() const;
  inline void clear_activetime();
  static const int kActiveTimeFieldNumber = 27;
  inline const ::std::string& activetime() const;
  inline void set_activetime(const ::std::string& value);
  inline void set_activetime(const char* value);
  inline void set_activetime(const char* value, size_t size);
  inline ::std::string* mutable_activetime();
  inline ::std::string* release_activetime();
  
  // required string SuspendTime = 28;
  inline bool has_suspendtime() const;
  inline void clear_suspendtime();
  static const int kSuspendTimeFieldNumber = 28;
  inline const ::std::string& suspendtime() const;
  inline void set_suspendtime(const ::std::string& value);
  inline void set_suspendtime(const char* value);
  inline void set_suspendtime(const char* value, size_t size);
  inline ::std::string* mutable_suspendtime();
  inline ::std::string* release_suspendtime();
  
  // required string UpdateTime = 29;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  static const int kUpdateTimeFieldNumber = 29;
  inline const ::std::string& updatetime() const;
  inline void set_updatetime(const ::std::string& value);
  inline void set_updatetime(const char* value);
  inline void set_updatetime(const char* value, size_t size);
  inline ::std::string* mutable_updatetime();
  inline ::std::string* release_updatetime();
  
  // required string CancelTime = 30;
  inline bool has_canceltime() const;
  inline void clear_canceltime();
  static const int kCancelTimeFieldNumber = 30;
  inline const ::std::string& canceltime() const;
  inline void set_canceltime(const ::std::string& value);
  inline void set_canceltime(const char* value);
  inline void set_canceltime(const char* value, size_t size);
  inline ::std::string* mutable_canceltime();
  inline ::std::string* release_canceltime();
  
  // required string ActiveTraderID = 31;
  inline bool has_activetraderid() const;
  inline void clear_activetraderid();
  static const int kActiveTraderIDFieldNumber = 31;
  inline const ::std::string& activetraderid() const;
  inline void set_activetraderid(const ::std::string& value);
  inline void set_activetraderid(const char* value);
  inline void set_activetraderid(const char* value, size_t size);
  inline ::std::string* mutable_activetraderid();
  inline ::std::string* release_activetraderid();
  
  // required string ClearingPartID = 32;
  inline bool has_clearingpartid() const;
  inline void clear_clearingpartid();
  static const int kClearingPartIDFieldNumber = 32;
  inline const ::std::string& clearingpartid() const;
  inline void set_clearingpartid(const ::std::string& value);
  inline void set_clearingpartid(const char* value);
  inline void set_clearingpartid(const char* value, size_t size);
  inline ::std::string* mutable_clearingpartid();
  inline ::std::string* release_clearingpartid();
  
  // required int32 SequenceNo = 33;
  inline bool has_sequenceno() const;
  inline void clear_sequenceno();
  static const int kSequenceNoFieldNumber = 33;
  inline ::google::protobuf::int32 sequenceno() const;
  inline void set_sequenceno(::google::protobuf::int32 value);
  
  // required int32 FrontID = 34;
  inline bool has_frontid() const;
  inline void clear_frontid();
  static const int kFrontIDFieldNumber = 34;
  inline ::google::protobuf::int32 frontid() const;
  inline void set_frontid(::google::protobuf::int32 value);
  
  // required int32 SessionID = 35;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 35;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);
  
  // required string UserProductInfo = 36;
  inline bool has_userproductinfo() const;
  inline void clear_userproductinfo();
  static const int kUserProductInfoFieldNumber = 36;
  inline const ::std::string& userproductinfo() const;
  inline void set_userproductinfo(const ::std::string& value);
  inline void set_userproductinfo(const char* value);
  inline void set_userproductinfo(const char* value, size_t size);
  inline ::std::string* mutable_userproductinfo();
  inline ::std::string* release_userproductinfo();
  
  // required string StatusMsg = 37;
  inline bool has_statusmsg() const;
  inline void clear_statusmsg();
  static const int kStatusMsgFieldNumber = 37;
  inline const ::std::string& statusmsg() const;
  inline void set_statusmsg(const ::std::string& value);
  inline void set_statusmsg(const char* value);
  inline void set_statusmsg(const char* value, size_t size);
  inline ::std::string* mutable_statusmsg();
  inline ::std::string* release_statusmsg();
  
  // required int32 UserForceClose = 38;
  inline bool has_userforceclose() const;
  inline void clear_userforceclose();
  static const int kUserForceCloseFieldNumber = 38;
  inline ::google::protobuf::int32 userforceclose() const;
  inline void set_userforceclose(::google::protobuf::int32 value);
  
  // required int32 BrokerOrderSeq = 39;
  inline bool has_brokerorderseq() const;
  inline void clear_brokerorderseq();
  static const int kBrokerOrderSeqFieldNumber = 39;
  inline ::google::protobuf::int32 brokerorderseq() const;
  inline void set_brokerorderseq(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcOrderField)
 private:
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_orderref();
  inline void clear_has_orderref();
  inline void set_has_orderpricetype();
  inline void clear_has_orderpricetype();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_comboffsetflag();
  inline void clear_has_comboffsetflag();
  inline void set_has_combhedgeflag();
  inline void clear_has_combhedgeflag();
  inline void set_has_limitprice();
  inline void clear_has_limitprice();
  inline void set_has_volumetotaloriginal();
  inline void clear_has_volumetotaloriginal();
  inline void set_has_timecondition();
  inline void clear_has_timecondition();
  inline void set_has_gtddate();
  inline void clear_has_gtddate();
  inline void set_has_requestid();
  inline void clear_has_requestid();
  inline void set_has_orderlocalid();
  inline void clear_has_orderlocalid();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  inline void set_has_exchangeinstid();
  inline void clear_has_exchangeinstid();
  inline void set_has_ordersubmitstatus();
  inline void clear_has_ordersubmitstatus();
  inline void set_has_notifysequence();
  inline void clear_has_notifysequence();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_ordersysid();
  inline void clear_has_ordersysid();
  inline void set_has_ordersource();
  inline void clear_has_ordersource();
  inline void set_has_orderstatus();
  inline void clear_has_orderstatus();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_volumetraded();
  inline void clear_has_volumetraded();
  inline void set_has_volumetotal();
  inline void clear_has_volumetotal();
  inline void set_has_insertdate();
  inline void clear_has_insertdate();
  inline void set_has_inserttime();
  inline void clear_has_inserttime();
  inline void set_has_activetime();
  inline void clear_has_activetime();
  inline void set_has_suspendtime();
  inline void clear_has_suspendtime();
  inline void set_has_updatetime();
  inline void clear_has_updatetime();
  inline void set_has_canceltime();
  inline void clear_has_canceltime();
  inline void set_has_activetraderid();
  inline void clear_has_activetraderid();
  inline void set_has_clearingpartid();
  inline void clear_has_clearingpartid();
  inline void set_has_sequenceno();
  inline void clear_has_sequenceno();
  inline void set_has_frontid();
  inline void clear_has_frontid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_userproductinfo();
  inline void clear_has_userproductinfo();
  inline void set_has_statusmsg();
  inline void clear_has_statusmsg();
  inline void set_has_userforceclose();
  inline void clear_has_userforceclose();
  inline void set_has_brokerorderseq();
  inline void clear_has_brokerorderseq();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrumentid_;
  ::std::string* orderref_;
  ::std::string* orderpricetype_;
  ::std::string* direction_;
  ::std::string* comboffsetflag_;
  ::std::string* combhedgeflag_;
  double limitprice_;
  ::std::string* timecondition_;
  ::google::protobuf::int32 volumetotaloriginal_;
  ::google::protobuf::int32 requestid_;
  ::std::string* gtddate_;
  ::std::string* orderlocalid_;
  ::std::string* exchangeid_;
  ::std::string* exchangeinstid_;
  ::std::string* ordersubmitstatus_;
  ::std::string* tradingday_;
  ::google::protobuf::int32 notifysequence_;
  ::google::protobuf::int32 settlementid_;
  ::std::string* ordersysid_;
  ::std::string* ordersource_;
  ::std::string* orderstatus_;
  ::std::string* ordertype_;
  ::google::protobuf::int32 volumetraded_;
  ::google::protobuf::int32 volumetotal_;
  ::std::string* insertdate_;
  ::std::string* inserttime_;
  ::std::string* activetime_;
  ::std::string* suspendtime_;
  ::std::string* updatetime_;
  ::std::string* canceltime_;
  ::std::string* activetraderid_;
  ::std::string* clearingpartid_;
  ::google::protobuf::int32 sequenceno_;
  ::google::protobuf::int32 frontid_;
  ::std::string* userproductinfo_;
  ::google::protobuf::int32 sessionid_;
  ::google::protobuf::int32 userforceclose_;
  ::std::string* statusmsg_;
  ::google::protobuf::int32 brokerorderseq_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(39 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcOrderField* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcTradeField : public ::google::protobuf::Message {
 public:
  MThostFtdcTradeField();
  virtual ~MThostFtdcTradeField();
  
  MThostFtdcTradeField(const MThostFtdcTradeField& from);
  
  inline MThostFtdcTradeField& operator=(const MThostFtdcTradeField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcTradeField& default_instance();
  
  void Swap(MThostFtdcTradeField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcTradeField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcTradeField& from);
  void MergeFrom(const MThostFtdcTradeField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string InstrumentID = 1;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 1;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  
  // required string OrderRef = 2;
  inline bool has_orderref() const;
  inline void clear_orderref();
  static const int kOrderRefFieldNumber = 2;
  inline const ::std::string& orderref() const;
  inline void set_orderref(const ::std::string& value);
  inline void set_orderref(const char* value);
  inline void set_orderref(const char* value, size_t size);
  inline ::std::string* mutable_orderref();
  inline ::std::string* release_orderref();
  
  // required string UserID = 3;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIDFieldNumber = 3;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  
  // required string ExchangeID = 4;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIDFieldNumber = 4;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // required string TradeID = 5;
  inline bool has_tradeid() const;
  inline void clear_tradeid();
  static const int kTradeIDFieldNumber = 5;
  inline const ::std::string& tradeid() const;
  inline void set_tradeid(const ::std::string& value);
  inline void set_tradeid(const char* value);
  inline void set_tradeid(const char* value, size_t size);
  inline ::std::string* mutable_tradeid();
  inline ::std::string* release_tradeid();
  
  // required string Direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline const ::std::string& direction() const;
  inline void set_direction(const ::std::string& value);
  inline void set_direction(const char* value);
  inline void set_direction(const char* value, size_t size);
  inline ::std::string* mutable_direction();
  inline ::std::string* release_direction();
  
  // required string OrderSysID = 7;
  inline bool has_ordersysid() const;
  inline void clear_ordersysid();
  static const int kOrderSysIDFieldNumber = 7;
  inline const ::std::string& ordersysid() const;
  inline void set_ordersysid(const ::std::string& value);
  inline void set_ordersysid(const char* value);
  inline void set_ordersysid(const char* value, size_t size);
  inline ::std::string* mutable_ordersysid();
  inline ::std::string* release_ordersysid();
  
  // required string ParticipantID = 8;
  inline bool has_participantid() const;
  inline void clear_participantid();
  static const int kParticipantIDFieldNumber = 8;
  inline const ::std::string& participantid() const;
  inline void set_participantid(const ::std::string& value);
  inline void set_participantid(const char* value);
  inline void set_participantid(const char* value, size_t size);
  inline ::std::string* mutable_participantid();
  inline ::std::string* release_participantid();
  
  // required string ClientID = 9;
  inline bool has_clientid() const;
  inline void clear_clientid();
  static const int kClientIDFieldNumber = 9;
  inline const ::std::string& clientid() const;
  inline void set_clientid(const ::std::string& value);
  inline void set_clientid(const char* value);
  inline void set_clientid(const char* value, size_t size);
  inline ::std::string* mutable_clientid();
  inline ::std::string* release_clientid();
  
  // required string TradingRole = 10;
  inline bool has_tradingrole() const;
  inline void clear_tradingrole();
  static const int kTradingRoleFieldNumber = 10;
  inline const ::std::string& tradingrole() const;
  inline void set_tradingrole(const ::std::string& value);
  inline void set_tradingrole(const char* value);
  inline void set_tradingrole(const char* value, size_t size);
  inline ::std::string* mutable_tradingrole();
  inline ::std::string* release_tradingrole();
  
  // required string ExchangeInstID = 11;
  inline bool has_exchangeinstid() const;
  inline void clear_exchangeinstid();
  static const int kExchangeInstIDFieldNumber = 11;
  inline const ::std::string& exchangeinstid() const;
  inline void set_exchangeinstid(const ::std::string& value);
  inline void set_exchangeinstid(const char* value);
  inline void set_exchangeinstid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeinstid();
  inline ::std::string* release_exchangeinstid();
  
  // required string OffsetFlag = 12;
  inline bool has_offsetflag() const;
  inline void clear_offsetflag();
  static const int kOffsetFlagFieldNumber = 12;
  inline const ::std::string& offsetflag() const;
  inline void set_offsetflag(const ::std::string& value);
  inline void set_offsetflag(const char* value);
  inline void set_offsetflag(const char* value, size_t size);
  inline ::std::string* mutable_offsetflag();
  inline ::std::string* release_offsetflag();
  
  // required string HedgeFlag = 13;
  inline bool has_hedgeflag() const;
  inline void clear_hedgeflag();
  static const int kHedgeFlagFieldNumber = 13;
  inline const ::std::string& hedgeflag() const;
  inline void set_hedgeflag(const ::std::string& value);
  inline void set_hedgeflag(const char* value);
  inline void set_hedgeflag(const char* value, size_t size);
  inline ::std::string* mutable_hedgeflag();
  inline ::std::string* release_hedgeflag();
  
  // required double Price = 14;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 14;
  inline double price() const;
  inline void set_price(double value);
  
  // required int32 Volume = 15;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 15;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);
  
  // required string TradeDate = 16;
  inline bool has_tradedate() const;
  inline void clear_tradedate();
  static const int kTradeDateFieldNumber = 16;
  inline const ::std::string& tradedate() const;
  inline void set_tradedate(const ::std::string& value);
  inline void set_tradedate(const char* value);
  inline void set_tradedate(const char* value, size_t size);
  inline ::std::string* mutable_tradedate();
  inline ::std::string* release_tradedate();
  
  // required string TradeTime = 17;
  inline bool has_tradetime() const;
  inline void clear_tradetime();
  static const int kTradeTimeFieldNumber = 17;
  inline const ::std::string& tradetime() const;
  inline void set_tradetime(const ::std::string& value);
  inline void set_tradetime(const char* value);
  inline void set_tradetime(const char* value, size_t size);
  inline ::std::string* mutable_tradetime();
  inline ::std::string* release_tradetime();
  
  // required string TradeType = 18;
  inline bool has_tradetype() const;
  inline void clear_tradetype();
  static const int kTradeTypeFieldNumber = 18;
  inline const ::std::string& tradetype() const;
  inline void set_tradetype(const ::std::string& value);
  inline void set_tradetype(const char* value);
  inline void set_tradetype(const char* value, size_t size);
  inline ::std::string* mutable_tradetype();
  inline ::std::string* release_tradetype();
  
  // required string PriceSource = 19;
  inline bool has_pricesource() const;
  inline void clear_pricesource();
  static const int kPriceSourceFieldNumber = 19;
  inline const ::std::string& pricesource() const;
  inline void set_pricesource(const ::std::string& value);
  inline void set_pricesource(const char* value);
  inline void set_pricesource(const char* value, size_t size);
  inline ::std::string* mutable_pricesource();
  inline ::std::string* release_pricesource();
  
  // required string TraderID = 20;
  inline bool has_traderid() const;
  inline void clear_traderid();
  static const int kTraderIDFieldNumber = 20;
  inline const ::std::string& traderid() const;
  inline void set_traderid(const ::std::string& value);
  inline void set_traderid(const char* value);
  inline void set_traderid(const char* value, size_t size);
  inline ::std::string* mutable_traderid();
  inline ::std::string* release_traderid();
  
  // required string OrderLocalID = 21;
  inline bool has_orderlocalid() const;
  inline void clear_orderlocalid();
  static const int kOrderLocalIDFieldNumber = 21;
  inline const ::std::string& orderlocalid() const;
  inline void set_orderlocalid(const ::std::string& value);
  inline void set_orderlocalid(const char* value);
  inline void set_orderlocalid(const char* value, size_t size);
  inline ::std::string* mutable_orderlocalid();
  inline ::std::string* release_orderlocalid();
  
  // required string ClearingPartID = 22;
  inline bool has_clearingpartid() const;
  inline void clear_clearingpartid();
  static const int kClearingPartIDFieldNumber = 22;
  inline const ::std::string& clearingpartid() const;
  inline void set_clearingpartid(const ::std::string& value);
  inline void set_clearingpartid(const char* value);
  inline void set_clearingpartid(const char* value, size_t size);
  inline ::std::string* mutable_clearingpartid();
  inline ::std::string* release_clearingpartid();
  
  // required int32 SequenceNo = 23;
  inline bool has_sequenceno() const;
  inline void clear_sequenceno();
  static const int kSequenceNoFieldNumber = 23;
  inline ::google::protobuf::int32 sequenceno() const;
  inline void set_sequenceno(::google::protobuf::int32 value);
  
  // required string TradingDay = 24;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingDayFieldNumber = 24;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  
  // required int32 SettlementID = 25;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementIDFieldNumber = 25;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);
  
  // required int32 BrokerOrderSeq = 26;
  inline bool has_brokerorderseq() const;
  inline void clear_brokerorderseq();
  static const int kBrokerOrderSeqFieldNumber = 26;
  inline ::google::protobuf::int32 brokerorderseq() const;
  inline void set_brokerorderseq(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcTradeField)
 private:
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_orderref();
  inline void clear_has_orderref();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  inline void set_has_tradeid();
  inline void clear_has_tradeid();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_ordersysid();
  inline void clear_has_ordersysid();
  inline void set_has_participantid();
  inline void clear_has_participantid();
  inline void set_has_clientid();
  inline void clear_has_clientid();
  inline void set_has_tradingrole();
  inline void clear_has_tradingrole();
  inline void set_has_exchangeinstid();
  inline void clear_has_exchangeinstid();
  inline void set_has_offsetflag();
  inline void clear_has_offsetflag();
  inline void set_has_hedgeflag();
  inline void clear_has_hedgeflag();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_tradedate();
  inline void clear_has_tradedate();
  inline void set_has_tradetime();
  inline void clear_has_tradetime();
  inline void set_has_tradetype();
  inline void clear_has_tradetype();
  inline void set_has_pricesource();
  inline void clear_has_pricesource();
  inline void set_has_traderid();
  inline void clear_has_traderid();
  inline void set_has_orderlocalid();
  inline void clear_has_orderlocalid();
  inline void set_has_clearingpartid();
  inline void clear_has_clearingpartid();
  inline void set_has_sequenceno();
  inline void clear_has_sequenceno();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_brokerorderseq();
  inline void clear_has_brokerorderseq();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrumentid_;
  ::std::string* orderref_;
  ::std::string* userid_;
  ::std::string* exchangeid_;
  ::std::string* tradeid_;
  ::std::string* direction_;
  ::std::string* ordersysid_;
  ::std::string* participantid_;
  ::std::string* clientid_;
  ::std::string* tradingrole_;
  ::std::string* exchangeinstid_;
  ::std::string* offsetflag_;
  ::std::string* hedgeflag_;
  double price_;
  ::std::string* tradedate_;
  ::std::string* tradetime_;
  ::std::string* tradetype_;
  ::std::string* pricesource_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 sequenceno_;
  ::std::string* traderid_;
  ::std::string* orderlocalid_;
  ::std::string* clearingpartid_;
  ::std::string* tradingday_;
  ::google::protobuf::int32 settlementid_;
  ::google::protobuf::int32 brokerorderseq_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcTradeField* default_instance_;
};
// -------------------------------------------------------------------

class OrderAction : public ::google::protobuf::Message {
 public:
  OrderAction();
  virtual ~OrderAction();
  
  OrderAction(const OrderAction& from);
  
  inline OrderAction& operator=(const OrderAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderAction& default_instance();
  
  void Swap(OrderAction* other);
  
  // implements Message ----------------------------------------------
  
  OrderAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderAction& from);
  void MergeFrom(const OrderAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 HandleID = 1;
  inline bool has_handleid() const;
  inline void clear_handleid();
  static const int kHandleIDFieldNumber = 1;
  inline ::google::protobuf::int32 handleid() const;
  inline void set_handleid(::google::protobuf::int32 value);
  
  // required int32 Ref = 2;
  inline bool has_ref() const;
  inline void clear_ref();
  static const int kRefFieldNumber = 2;
  inline ::google::protobuf::int32 ref() const;
  inline void set_ref(::google::protobuf::int32 value);
  
  // optional string OrderSysID = 3;
  inline bool has_ordersysid() const;
  inline void clear_ordersysid();
  static const int kOrderSysIDFieldNumber = 3;
  inline const ::std::string& ordersysid() const;
  inline void set_ordersysid(const ::std::string& value);
  inline void set_ordersysid(const char* value);
  inline void set_ordersysid(const char* value, size_t size);
  inline ::std::string* mutable_ordersysid();
  inline ::std::string* release_ordersysid();
  
  // optional int32 FrontID = 4;
  inline bool has_frontid() const;
  inline void clear_frontid();
  static const int kFrontIDFieldNumber = 4;
  inline ::google::protobuf::int32 frontid() const;
  inline void set_frontid(::google::protobuf::int32 value);
  
  // optional int32 SessionID = 5;
  inline bool has_sessionid() const;
  inline void clear_sessionid();
  static const int kSessionIDFieldNumber = 5;
  inline ::google::protobuf::int32 sessionid() const;
  inline void set_sessionid(::google::protobuf::int32 value);
  
  // optional string ExchangeID = 6;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIDFieldNumber = 6;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.OrderAction)
 private:
  inline void set_has_handleid();
  inline void clear_has_handleid();
  inline void set_has_ref();
  inline void clear_has_ref();
  inline void set_has_ordersysid();
  inline void clear_has_ordersysid();
  inline void set_has_frontid();
  inline void clear_has_frontid();
  inline void set_has_sessionid();
  inline void clear_has_sessionid();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 handleid_;
  ::google::protobuf::int32 ref_;
  ::std::string* ordersysid_;
  ::google::protobuf::int32 frontid_;
  ::google::protobuf::int32 sessionid_;
  ::std::string* exchangeid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static OrderAction* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcQryInvestorPositionField : public ::google::protobuf::Message {
 public:
  MThostFtdcQryInvestorPositionField();
  virtual ~MThostFtdcQryInvestorPositionField();
  
  MThostFtdcQryInvestorPositionField(const MThostFtdcQryInvestorPositionField& from);
  
  inline MThostFtdcQryInvestorPositionField& operator=(const MThostFtdcQryInvestorPositionField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcQryInvestorPositionField& default_instance();
  
  void Swap(MThostFtdcQryInvestorPositionField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcQryInvestorPositionField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcQryInvestorPositionField& from);
  void MergeFrom(const MThostFtdcQryInvestorPositionField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated string InstrumentID = 1;
  inline int instrumentid_size() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 1;
  inline const ::std::string& instrumentid(int index) const;
  inline ::std::string* mutable_instrumentid(int index);
  inline void set_instrumentid(int index, const ::std::string& value);
  inline void set_instrumentid(int index, const char* value);
  inline void set_instrumentid(int index, const char* value, size_t size);
  inline ::std::string* add_instrumentid();
  inline void add_instrumentid(const ::std::string& value);
  inline void add_instrumentid(const char* value);
  inline void add_instrumentid(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& instrumentid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_instrumentid();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcQryInvestorPositionField)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::std::string> instrumentid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcQryInvestorPositionField* default_instance_;
};
// -------------------------------------------------------------------

class RtnMThostFtdcQryInvestorPositionField : public ::google::protobuf::Message {
 public:
  RtnMThostFtdcQryInvestorPositionField();
  virtual ~RtnMThostFtdcQryInvestorPositionField();
  
  RtnMThostFtdcQryInvestorPositionField(const RtnMThostFtdcQryInvestorPositionField& from);
  
  inline RtnMThostFtdcQryInvestorPositionField& operator=(const RtnMThostFtdcQryInvestorPositionField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RtnMThostFtdcQryInvestorPositionField& default_instance();
  
  void Swap(RtnMThostFtdcQryInvestorPositionField* other);
  
  // implements Message ----------------------------------------------
  
  RtnMThostFtdcQryInvestorPositionField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RtnMThostFtdcQryInvestorPositionField& from);
  void MergeFrom(const RtnMThostFtdcQryInvestorPositionField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .FutureTradingPB.MThostFtdcInvestorPositionField InvestorPosition = 1;
  inline int investorposition_size() const;
  inline void clear_investorposition();
  static const int kInvestorPositionFieldNumber = 1;
  inline const ::FutureTradingPB::MThostFtdcInvestorPositionField& investorposition(int index) const;
  inline ::FutureTradingPB::MThostFtdcInvestorPositionField* mutable_investorposition(int index);
  inline ::FutureTradingPB::MThostFtdcInvestorPositionField* add_investorposition();
  inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInvestorPositionField >&
      investorposition() const;
  inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInvestorPositionField >*
      mutable_investorposition();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.RtnMThostFtdcQryInvestorPositionField)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInvestorPositionField > investorposition_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static RtnMThostFtdcQryInvestorPositionField* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcInvestorPositionField : public ::google::protobuf::Message {
 public:
  MThostFtdcInvestorPositionField();
  virtual ~MThostFtdcInvestorPositionField();
  
  MThostFtdcInvestorPositionField(const MThostFtdcInvestorPositionField& from);
  
  inline MThostFtdcInvestorPositionField& operator=(const MThostFtdcInvestorPositionField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcInvestorPositionField& default_instance();
  
  void Swap(MThostFtdcInvestorPositionField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcInvestorPositionField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcInvestorPositionField& from);
  void MergeFrom(const MThostFtdcInvestorPositionField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string InstrumentID = 1;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 1;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  
  // required string PosiDirection = 2;
  inline bool has_posidirection() const;
  inline void clear_posidirection();
  static const int kPosiDirectionFieldNumber = 2;
  inline const ::std::string& posidirection() const;
  inline void set_posidirection(const ::std::string& value);
  inline void set_posidirection(const char* value);
  inline void set_posidirection(const char* value, size_t size);
  inline ::std::string* mutable_posidirection();
  inline ::std::string* release_posidirection();
  
  // required string HedgeFlag = 3;
  inline bool has_hedgeflag() const;
  inline void clear_hedgeflag();
  static const int kHedgeFlagFieldNumber = 3;
  inline const ::std::string& hedgeflag() const;
  inline void set_hedgeflag(const ::std::string& value);
  inline void set_hedgeflag(const char* value);
  inline void set_hedgeflag(const char* value, size_t size);
  inline ::std::string* mutable_hedgeflag();
  inline ::std::string* release_hedgeflag();
  
  // required string PositionDate = 4;
  inline bool has_positiondate() const;
  inline void clear_positiondate();
  static const int kPositionDateFieldNumber = 4;
  inline const ::std::string& positiondate() const;
  inline void set_positiondate(const ::std::string& value);
  inline void set_positiondate(const char* value);
  inline void set_positiondate(const char* value, size_t size);
  inline ::std::string* mutable_positiondate();
  inline ::std::string* release_positiondate();
  
  // required int32 YdPosition = 5;
  inline bool has_ydposition() const;
  inline void clear_ydposition();
  static const int kYdPositionFieldNumber = 5;
  inline ::google::protobuf::int32 ydposition() const;
  inline void set_ydposition(::google::protobuf::int32 value);
  
  // required int32 Position = 6;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 6;
  inline ::google::protobuf::int32 position() const;
  inline void set_position(::google::protobuf::int32 value);
  
  // required int32 LongFrozen = 7;
  inline bool has_longfrozen() const;
  inline void clear_longfrozen();
  static const int kLongFrozenFieldNumber = 7;
  inline ::google::protobuf::int32 longfrozen() const;
  inline void set_longfrozen(::google::protobuf::int32 value);
  
  // required int32 ShortFrozen = 8;
  inline bool has_shortfrozen() const;
  inline void clear_shortfrozen();
  static const int kShortFrozenFieldNumber = 8;
  inline ::google::protobuf::int32 shortfrozen() const;
  inline void set_shortfrozen(::google::protobuf::int32 value);
  
  // required double LongFrozenAmount = 9;
  inline bool has_longfrozenamount() const;
  inline void clear_longfrozenamount();
  static const int kLongFrozenAmountFieldNumber = 9;
  inline double longfrozenamount() const;
  inline void set_longfrozenamount(double value);
  
  // required double ShortFrozenAmount = 10;
  inline bool has_shortfrozenamount() const;
  inline void clear_shortfrozenamount();
  static const int kShortFrozenAmountFieldNumber = 10;
  inline double shortfrozenamount() const;
  inline void set_shortfrozenamount(double value);
  
  // required int32 OpenVolume = 11;
  inline bool has_openvolume() const;
  inline void clear_openvolume();
  static const int kOpenVolumeFieldNumber = 11;
  inline ::google::protobuf::int32 openvolume() const;
  inline void set_openvolume(::google::protobuf::int32 value);
  
  // required int32 CloseVolume = 12;
  inline bool has_closevolume() const;
  inline void clear_closevolume();
  static const int kCloseVolumeFieldNumber = 12;
  inline ::google::protobuf::int32 closevolume() const;
  inline void set_closevolume(::google::protobuf::int32 value);
  
  // required double OpenAmount = 13;
  inline bool has_openamount() const;
  inline void clear_openamount();
  static const int kOpenAmountFieldNumber = 13;
  inline double openamount() const;
  inline void set_openamount(double value);
  
  // required double CloseAmount = 14;
  inline bool has_closeamount() const;
  inline void clear_closeamount();
  static const int kCloseAmountFieldNumber = 14;
  inline double closeamount() const;
  inline void set_closeamount(double value);
  
  // required double PositionCost = 15;
  inline bool has_positioncost() const;
  inline void clear_positioncost();
  static const int kPositionCostFieldNumber = 15;
  inline double positioncost() const;
  inline void set_positioncost(double value);
  
  // required double PreMargin = 16;
  inline bool has_premargin() const;
  inline void clear_premargin();
  static const int kPreMarginFieldNumber = 16;
  inline double premargin() const;
  inline void set_premargin(double value);
  
  // required double UseMargin = 17;
  inline bool has_usemargin() const;
  inline void clear_usemargin();
  static const int kUseMarginFieldNumber = 17;
  inline double usemargin() const;
  inline void set_usemargin(double value);
  
  // required double FrozenMargin = 18;
  inline bool has_frozenmargin() const;
  inline void clear_frozenmargin();
  static const int kFrozenMarginFieldNumber = 18;
  inline double frozenmargin() const;
  inline void set_frozenmargin(double value);
  
  // required double FrozenCash = 19;
  inline bool has_frozencash() const;
  inline void clear_frozencash();
  static const int kFrozenCashFieldNumber = 19;
  inline double frozencash() const;
  inline void set_frozencash(double value);
  
  // required double FrozenCommission = 20;
  inline bool has_frozencommission() const;
  inline void clear_frozencommission();
  static const int kFrozenCommissionFieldNumber = 20;
  inline double frozencommission() const;
  inline void set_frozencommission(double value);
  
  // required double CashIn = 21;
  inline bool has_cashin() const;
  inline void clear_cashin();
  static const int kCashInFieldNumber = 21;
  inline double cashin() const;
  inline void set_cashin(double value);
  
  // required double Commission = 22;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 22;
  inline double commission() const;
  inline void set_commission(double value);
  
  // required double CloseProfit = 23;
  inline bool has_closeprofit() const;
  inline void clear_closeprofit();
  static const int kCloseProfitFieldNumber = 23;
  inline double closeprofit() const;
  inline void set_closeprofit(double value);
  
  // required double PositionProfit = 24;
  inline bool has_positionprofit() const;
  inline void clear_positionprofit();
  static const int kPositionProfitFieldNumber = 24;
  inline double positionprofit() const;
  inline void set_positionprofit(double value);
  
  // required double PreSettlementPrice = 25;
  inline bool has_presettlementprice() const;
  inline void clear_presettlementprice();
  static const int kPreSettlementPriceFieldNumber = 25;
  inline double presettlementprice() const;
  inline void set_presettlementprice(double value);
  
  // required double SettlementPrice = 26;
  inline bool has_settlementprice() const;
  inline void clear_settlementprice();
  static const int kSettlementPriceFieldNumber = 26;
  inline double settlementprice() const;
  inline void set_settlementprice(double value);
  
  // required string TradingDay = 27;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingDayFieldNumber = 27;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  
  // required int32 SettlementID = 28;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementIDFieldNumber = 28;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);
  
  // required double OpenCost = 29;
  inline bool has_opencost() const;
  inline void clear_opencost();
  static const int kOpenCostFieldNumber = 29;
  inline double opencost() const;
  inline void set_opencost(double value);
  
  // required double ExchangeMargin = 30;
  inline bool has_exchangemargin() const;
  inline void clear_exchangemargin();
  static const int kExchangeMarginFieldNumber = 30;
  inline double exchangemargin() const;
  inline void set_exchangemargin(double value);
  
  // required double CombPosition = 31;
  inline bool has_combposition() const;
  inline void clear_combposition();
  static const int kCombPositionFieldNumber = 31;
  inline double combposition() const;
  inline void set_combposition(double value);
  
  // required double CombLongFrozen = 32;
  inline bool has_comblongfrozen() const;
  inline void clear_comblongfrozen();
  static const int kCombLongFrozenFieldNumber = 32;
  inline double comblongfrozen() const;
  inline void set_comblongfrozen(double value);
  
  // required double CombShortFrozen = 33;
  inline bool has_combshortfrozen() const;
  inline void clear_combshortfrozen();
  static const int kCombShortFrozenFieldNumber = 33;
  inline double combshortfrozen() const;
  inline void set_combshortfrozen(double value);
  
  // required double CloseProfitByDate = 34;
  inline bool has_closeprofitbydate() const;
  inline void clear_closeprofitbydate();
  static const int kCloseProfitByDateFieldNumber = 34;
  inline double closeprofitbydate() const;
  inline void set_closeprofitbydate(double value);
  
  // required double CloseProfitByTrade = 35;
  inline bool has_closeprofitbytrade() const;
  inline void clear_closeprofitbytrade();
  static const int kCloseProfitByTradeFieldNumber = 35;
  inline double closeprofitbytrade() const;
  inline void set_closeprofitbytrade(double value);
  
  // required double TodayPosition = 36;
  inline bool has_todayposition() const;
  inline void clear_todayposition();
  static const int kTodayPositionFieldNumber = 36;
  inline double todayposition() const;
  inline void set_todayposition(double value);
  
  // required double MarginRateByMoney = 37;
  inline bool has_marginratebymoney() const;
  inline void clear_marginratebymoney();
  static const int kMarginRateByMoneyFieldNumber = 37;
  inline double marginratebymoney() const;
  inline void set_marginratebymoney(double value);
  
  // required double MarginRateByVolume = 38;
  inline bool has_marginratebyvolume() const;
  inline void clear_marginratebyvolume();
  static const int kMarginRateByVolumeFieldNumber = 38;
  inline double marginratebyvolume() const;
  inline void set_marginratebyvolume(double value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcInvestorPositionField)
 private:
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_posidirection();
  inline void clear_has_posidirection();
  inline void set_has_hedgeflag();
  inline void clear_has_hedgeflag();
  inline void set_has_positiondate();
  inline void clear_has_positiondate();
  inline void set_has_ydposition();
  inline void clear_has_ydposition();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_longfrozen();
  inline void clear_has_longfrozen();
  inline void set_has_shortfrozen();
  inline void clear_has_shortfrozen();
  inline void set_has_longfrozenamount();
  inline void clear_has_longfrozenamount();
  inline void set_has_shortfrozenamount();
  inline void clear_has_shortfrozenamount();
  inline void set_has_openvolume();
  inline void clear_has_openvolume();
  inline void set_has_closevolume();
  inline void clear_has_closevolume();
  inline void set_has_openamount();
  inline void clear_has_openamount();
  inline void set_has_closeamount();
  inline void clear_has_closeamount();
  inline void set_has_positioncost();
  inline void clear_has_positioncost();
  inline void set_has_premargin();
  inline void clear_has_premargin();
  inline void set_has_usemargin();
  inline void clear_has_usemargin();
  inline void set_has_frozenmargin();
  inline void clear_has_frozenmargin();
  inline void set_has_frozencash();
  inline void clear_has_frozencash();
  inline void set_has_frozencommission();
  inline void clear_has_frozencommission();
  inline void set_has_cashin();
  inline void clear_has_cashin();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_closeprofit();
  inline void clear_has_closeprofit();
  inline void set_has_positionprofit();
  inline void clear_has_positionprofit();
  inline void set_has_presettlementprice();
  inline void clear_has_presettlementprice();
  inline void set_has_settlementprice();
  inline void clear_has_settlementprice();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_opencost();
  inline void clear_has_opencost();
  inline void set_has_exchangemargin();
  inline void clear_has_exchangemargin();
  inline void set_has_combposition();
  inline void clear_has_combposition();
  inline void set_has_comblongfrozen();
  inline void clear_has_comblongfrozen();
  inline void set_has_combshortfrozen();
  inline void clear_has_combshortfrozen();
  inline void set_has_closeprofitbydate();
  inline void clear_has_closeprofitbydate();
  inline void set_has_closeprofitbytrade();
  inline void clear_has_closeprofitbytrade();
  inline void set_has_todayposition();
  inline void clear_has_todayposition();
  inline void set_has_marginratebymoney();
  inline void clear_has_marginratebymoney();
  inline void set_has_marginratebyvolume();
  inline void clear_has_marginratebyvolume();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrumentid_;
  ::std::string* posidirection_;
  ::std::string* hedgeflag_;
  ::std::string* positiondate_;
  ::google::protobuf::int32 ydposition_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::int32 longfrozen_;
  ::google::protobuf::int32 shortfrozen_;
  double longfrozenamount_;
  double shortfrozenamount_;
  ::google::protobuf::int32 openvolume_;
  ::google::protobuf::int32 closevolume_;
  double openamount_;
  double closeamount_;
  double positioncost_;
  double premargin_;
  double usemargin_;
  double frozenmargin_;
  double frozencash_;
  double frozencommission_;
  double cashin_;
  double commission_;
  double closeprofit_;
  double positionprofit_;
  double presettlementprice_;
  double settlementprice_;
  ::std::string* tradingday_;
  double opencost_;
  double exchangemargin_;
  double combposition_;
  double comblongfrozen_;
  double combshortfrozen_;
  double closeprofitbydate_;
  double closeprofitbytrade_;
  double todayposition_;
  double marginratebymoney_;
  double marginratebyvolume_;
  ::google::protobuf::int32 settlementid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(38 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcInvestorPositionField* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcTradingAccountField : public ::google::protobuf::Message {
 public:
  MThostFtdcTradingAccountField();
  virtual ~MThostFtdcTradingAccountField();
  
  MThostFtdcTradingAccountField(const MThostFtdcTradingAccountField& from);
  
  inline MThostFtdcTradingAccountField& operator=(const MThostFtdcTradingAccountField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcTradingAccountField& default_instance();
  
  void Swap(MThostFtdcTradingAccountField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcTradingAccountField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcTradingAccountField& from);
  void MergeFrom(const MThostFtdcTradingAccountField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string BrokerID = 1;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIDFieldNumber = 1;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string AccountID = 2;
  inline bool has_accountid() const;
  inline void clear_accountid();
  static const int kAccountIDFieldNumber = 2;
  inline const ::std::string& accountid() const;
  inline void set_accountid(const ::std::string& value);
  inline void set_accountid(const char* value);
  inline void set_accountid(const char* value, size_t size);
  inline ::std::string* mutable_accountid();
  inline ::std::string* release_accountid();
  
  // required double PreMortgage = 3;
  inline bool has_premortgage() const;
  inline void clear_premortgage();
  static const int kPreMortgageFieldNumber = 3;
  inline double premortgage() const;
  inline void set_premortgage(double value);
  
  // required double PreCredit = 4;
  inline bool has_precredit() const;
  inline void clear_precredit();
  static const int kPreCreditFieldNumber = 4;
  inline double precredit() const;
  inline void set_precredit(double value);
  
  // required double PreDeposit = 5;
  inline bool has_predeposit() const;
  inline void clear_predeposit();
  static const int kPreDepositFieldNumber = 5;
  inline double predeposit() const;
  inline void set_predeposit(double value);
  
  // required double PreBalance = 6;
  inline bool has_prebalance() const;
  inline void clear_prebalance();
  static const int kPreBalanceFieldNumber = 6;
  inline double prebalance() const;
  inline void set_prebalance(double value);
  
  // required double PreMargin = 7;
  inline bool has_premargin() const;
  inline void clear_premargin();
  static const int kPreMarginFieldNumber = 7;
  inline double premargin() const;
  inline void set_premargin(double value);
  
  // required double InterestBase = 8;
  inline bool has_interestbase() const;
  inline void clear_interestbase();
  static const int kInterestBaseFieldNumber = 8;
  inline double interestbase() const;
  inline void set_interestbase(double value);
  
  // required double Interest = 9;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 9;
  inline double interest() const;
  inline void set_interest(double value);
  
  // required double Deposit = 10;
  inline bool has_deposit() const;
  inline void clear_deposit();
  static const int kDepositFieldNumber = 10;
  inline double deposit() const;
  inline void set_deposit(double value);
  
  // required double Withdraw = 11;
  inline bool has_withdraw() const;
  inline void clear_withdraw();
  static const int kWithdrawFieldNumber = 11;
  inline double withdraw() const;
  inline void set_withdraw(double value);
  
  // required double FrozenMargin = 12;
  inline bool has_frozenmargin() const;
  inline void clear_frozenmargin();
  static const int kFrozenMarginFieldNumber = 12;
  inline double frozenmargin() const;
  inline void set_frozenmargin(double value);
  
  // required double FrozenCash = 13;
  inline bool has_frozencash() const;
  inline void clear_frozencash();
  static const int kFrozenCashFieldNumber = 13;
  inline double frozencash() const;
  inline void set_frozencash(double value);
  
  // required double FrozenCommission = 14;
  inline bool has_frozencommission() const;
  inline void clear_frozencommission();
  static const int kFrozenCommissionFieldNumber = 14;
  inline double frozencommission() const;
  inline void set_frozencommission(double value);
  
  // required double CurrMargin = 15;
  inline bool has_currmargin() const;
  inline void clear_currmargin();
  static const int kCurrMarginFieldNumber = 15;
  inline double currmargin() const;
  inline void set_currmargin(double value);
  
  // required double CashIn = 16;
  inline bool has_cashin() const;
  inline void clear_cashin();
  static const int kCashInFieldNumber = 16;
  inline double cashin() const;
  inline void set_cashin(double value);
  
  // required double Commission = 17;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 17;
  inline double commission() const;
  inline void set_commission(double value);
  
  // required double CloseProfit = 18;
  inline bool has_closeprofit() const;
  inline void clear_closeprofit();
  static const int kCloseProfitFieldNumber = 18;
  inline double closeprofit() const;
  inline void set_closeprofit(double value);
  
  // required double PositionProfit = 19;
  inline bool has_positionprofit() const;
  inline void clear_positionprofit();
  static const int kPositionProfitFieldNumber = 19;
  inline double positionprofit() const;
  inline void set_positionprofit(double value);
  
  // required double Balance = 20;
  inline bool has_balance() const;
  inline void clear_balance();
  static const int kBalanceFieldNumber = 20;
  inline double balance() const;
  inline void set_balance(double value);
  
  // required double Available = 21;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 21;
  inline double available() const;
  inline void set_available(double value);
  
  // required double WithdrawQuota = 22;
  inline bool has_withdrawquota() const;
  inline void clear_withdrawquota();
  static const int kWithdrawQuotaFieldNumber = 22;
  inline double withdrawquota() const;
  inline void set_withdrawquota(double value);
  
  // required double Reserve = 23;
  inline bool has_reserve() const;
  inline void clear_reserve();
  static const int kReserveFieldNumber = 23;
  inline double reserve() const;
  inline void set_reserve(double value);
  
  // required string TradingDay = 24;
  inline bool has_tradingday() const;
  inline void clear_tradingday();
  static const int kTradingDayFieldNumber = 24;
  inline const ::std::string& tradingday() const;
  inline void set_tradingday(const ::std::string& value);
  inline void set_tradingday(const char* value);
  inline void set_tradingday(const char* value, size_t size);
  inline ::std::string* mutable_tradingday();
  inline ::std::string* release_tradingday();
  
  // required int32 SettlementID = 25;
  inline bool has_settlementid() const;
  inline void clear_settlementid();
  static const int kSettlementIDFieldNumber = 25;
  inline ::google::protobuf::int32 settlementid() const;
  inline void set_settlementid(::google::protobuf::int32 value);
  
  // required double Credit = 26;
  inline bool has_credit() const;
  inline void clear_credit();
  static const int kCreditFieldNumber = 26;
  inline double credit() const;
  inline void set_credit(double value);
  
  // required double Mortgage = 27;
  inline bool has_mortgage() const;
  inline void clear_mortgage();
  static const int kMortgageFieldNumber = 27;
  inline double mortgage() const;
  inline void set_mortgage(double value);
  
  // required double ExchangeMargin = 28;
  inline bool has_exchangemargin() const;
  inline void clear_exchangemargin();
  static const int kExchangeMarginFieldNumber = 28;
  inline double exchangemargin() const;
  inline void set_exchangemargin(double value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcTradingAccountField)
 private:
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_accountid();
  inline void clear_has_accountid();
  inline void set_has_premortgage();
  inline void clear_has_premortgage();
  inline void set_has_precredit();
  inline void clear_has_precredit();
  inline void set_has_predeposit();
  inline void clear_has_predeposit();
  inline void set_has_prebalance();
  inline void clear_has_prebalance();
  inline void set_has_premargin();
  inline void clear_has_premargin();
  inline void set_has_interestbase();
  inline void clear_has_interestbase();
  inline void set_has_interest();
  inline void clear_has_interest();
  inline void set_has_deposit();
  inline void clear_has_deposit();
  inline void set_has_withdraw();
  inline void clear_has_withdraw();
  inline void set_has_frozenmargin();
  inline void clear_has_frozenmargin();
  inline void set_has_frozencash();
  inline void clear_has_frozencash();
  inline void set_has_frozencommission();
  inline void clear_has_frozencommission();
  inline void set_has_currmargin();
  inline void clear_has_currmargin();
  inline void set_has_cashin();
  inline void clear_has_cashin();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_closeprofit();
  inline void clear_has_closeprofit();
  inline void set_has_positionprofit();
  inline void clear_has_positionprofit();
  inline void set_has_balance();
  inline void clear_has_balance();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_withdrawquota();
  inline void clear_has_withdrawquota();
  inline void set_has_reserve();
  inline void clear_has_reserve();
  inline void set_has_tradingday();
  inline void clear_has_tradingday();
  inline void set_has_settlementid();
  inline void clear_has_settlementid();
  inline void set_has_credit();
  inline void clear_has_credit();
  inline void set_has_mortgage();
  inline void clear_has_mortgage();
  inline void set_has_exchangemargin();
  inline void clear_has_exchangemargin();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* brokerid_;
  ::std::string* accountid_;
  double premortgage_;
  double precredit_;
  double predeposit_;
  double prebalance_;
  double premargin_;
  double interestbase_;
  double interest_;
  double deposit_;
  double withdraw_;
  double frozenmargin_;
  double frozencash_;
  double frozencommission_;
  double currmargin_;
  double cashin_;
  double commission_;
  double closeprofit_;
  double positionprofit_;
  double balance_;
  double available_;
  double withdrawquota_;
  double reserve_;
  ::std::string* tradingday_;
  double credit_;
  double mortgage_;
  double exchangemargin_;
  ::google::protobuf::int32 settlementid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(28 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcTradingAccountField* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcQryTradingAccountField : public ::google::protobuf::Message {
 public:
  MThostFtdcQryTradingAccountField();
  virtual ~MThostFtdcQryTradingAccountField();
  
  MThostFtdcQryTradingAccountField(const MThostFtdcQryTradingAccountField& from);
  
  inline MThostFtdcQryTradingAccountField& operator=(const MThostFtdcQryTradingAccountField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcQryTradingAccountField& default_instance();
  
  void Swap(MThostFtdcQryTradingAccountField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcQryTradingAccountField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcQryTradingAccountField& from);
  void MergeFrom(const MThostFtdcQryTradingAccountField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string BrokerID = 1;
  inline bool has_brokerid() const;
  inline void clear_brokerid();
  static const int kBrokerIDFieldNumber = 1;
  inline const ::std::string& brokerid() const;
  inline void set_brokerid(const ::std::string& value);
  inline void set_brokerid(const char* value);
  inline void set_brokerid(const char* value, size_t size);
  inline ::std::string* mutable_brokerid();
  inline ::std::string* release_brokerid();
  
  // required string InvestorID = 2;
  inline bool has_investorid() const;
  inline void clear_investorid();
  static const int kInvestorIDFieldNumber = 2;
  inline const ::std::string& investorid() const;
  inline void set_investorid(const ::std::string& value);
  inline void set_investorid(const char* value);
  inline void set_investorid(const char* value, size_t size);
  inline ::std::string* mutable_investorid();
  inline ::std::string* release_investorid();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcQryTradingAccountField)
 private:
  inline void set_has_brokerid();
  inline void clear_has_brokerid();
  inline void set_has_investorid();
  inline void clear_has_investorid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* brokerid_;
  ::std::string* investorid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcQryTradingAccountField* default_instance_;
};
// -------------------------------------------------------------------

class ConRequest : public ::google::protobuf::Message {
 public:
  ConRequest();
  virtual ~ConRequest();
  
  ConRequest(const ConRequest& from);
  
  inline ConRequest& operator=(const ConRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConRequest& default_instance();
  
  void Swap(ConRequest* other);
  
  // implements Message ----------------------------------------------
  
  ConRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConRequest& from);
  void MergeFrom(const ConRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 QueType = 1;
  inline bool has_quetype() const;
  inline void clear_quetype();
  static const int kQueTypeFieldNumber = 1;
  inline ::google::protobuf::int32 quetype() const;
  inline void set_quetype(::google::protobuf::int32 value);
  
  // required string ContractList = 2;
  inline bool has_contractlist() const;
  inline void clear_contractlist();
  static const int kContractListFieldNumber = 2;
  inline const ::std::string& contractlist() const;
  inline void set_contractlist(const ::std::string& value);
  inline void set_contractlist(const char* value);
  inline void set_contractlist(const char* value, size_t size);
  inline ::std::string* mutable_contractlist();
  inline ::std::string* release_contractlist();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.ConRequest)
 private:
  inline void set_has_quetype();
  inline void clear_has_quetype();
  inline void set_has_contractlist();
  inline void clear_has_contractlist();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* contractlist_;
  ::google::protobuf::int32 quetype_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static ConRequest* default_instance_;
};
// -------------------------------------------------------------------

class ConResponse : public ::google::protobuf::Message {
 public:
  ConResponse();
  virtual ~ConResponse();
  
  ConResponse(const ConResponse& from);
  
  inline ConResponse& operator=(const ConResponse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ConResponse& default_instance();
  
  void Swap(ConResponse* other);
  
  // implements Message ----------------------------------------------
  
  ConResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConResponse& from);
  void MergeFrom(const ConResponse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 TimeStamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::int32 timestamp() const;
  inline void set_timestamp(::google::protobuf::int32 value);
  
  // repeated .FutureTradingPB.MThostFtdcInstrumentField ContractList = 2;
  inline int contractlist_size() const;
  inline void clear_contractlist();
  static const int kContractListFieldNumber = 2;
  inline const ::FutureTradingPB::MThostFtdcInstrumentField& contractlist(int index) const;
  inline ::FutureTradingPB::MThostFtdcInstrumentField* mutable_contractlist(int index);
  inline ::FutureTradingPB::MThostFtdcInstrumentField* add_contractlist();
  inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInstrumentField >&
      contractlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInstrumentField >*
      mutable_contractlist();
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.ConResponse)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInstrumentField > contractlist_;
  ::google::protobuf::int32 timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static ConResponse* default_instance_;
};
// -------------------------------------------------------------------

class MThostFtdcInstrumentField : public ::google::protobuf::Message {
 public:
  MThostFtdcInstrumentField();
  virtual ~MThostFtdcInstrumentField();
  
  MThostFtdcInstrumentField(const MThostFtdcInstrumentField& from);
  
  inline MThostFtdcInstrumentField& operator=(const MThostFtdcInstrumentField& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MThostFtdcInstrumentField& default_instance();
  
  void Swap(MThostFtdcInstrumentField* other);
  
  // implements Message ----------------------------------------------
  
  MThostFtdcInstrumentField* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MThostFtdcInstrumentField& from);
  void MergeFrom(const MThostFtdcInstrumentField& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string InstrumentID = 1;
  inline bool has_instrumentid() const;
  inline void clear_instrumentid();
  static const int kInstrumentIDFieldNumber = 1;
  inline const ::std::string& instrumentid() const;
  inline void set_instrumentid(const ::std::string& value);
  inline void set_instrumentid(const char* value);
  inline void set_instrumentid(const char* value, size_t size);
  inline ::std::string* mutable_instrumentid();
  inline ::std::string* release_instrumentid();
  
  // required string ExchangeID = 2;
  inline bool has_exchangeid() const;
  inline void clear_exchangeid();
  static const int kExchangeIDFieldNumber = 2;
  inline const ::std::string& exchangeid() const;
  inline void set_exchangeid(const ::std::string& value);
  inline void set_exchangeid(const char* value);
  inline void set_exchangeid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeid();
  inline ::std::string* release_exchangeid();
  
  // required string InstrumentName = 3;
  inline bool has_instrumentname() const;
  inline void clear_instrumentname();
  static const int kInstrumentNameFieldNumber = 3;
  inline const ::std::string& instrumentname() const;
  inline void set_instrumentname(const ::std::string& value);
  inline void set_instrumentname(const char* value);
  inline void set_instrumentname(const char* value, size_t size);
  inline ::std::string* mutable_instrumentname();
  inline ::std::string* release_instrumentname();
  
  // required string ExchangeInstID = 4;
  inline bool has_exchangeinstid() const;
  inline void clear_exchangeinstid();
  static const int kExchangeInstIDFieldNumber = 4;
  inline const ::std::string& exchangeinstid() const;
  inline void set_exchangeinstid(const ::std::string& value);
  inline void set_exchangeinstid(const char* value);
  inline void set_exchangeinstid(const char* value, size_t size);
  inline ::std::string* mutable_exchangeinstid();
  inline ::std::string* release_exchangeinstid();
  
  // required string ProductID = 5;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIDFieldNumber = 5;
  inline const ::std::string& productid() const;
  inline void set_productid(const ::std::string& value);
  inline void set_productid(const char* value);
  inline void set_productid(const char* value, size_t size);
  inline ::std::string* mutable_productid();
  inline ::std::string* release_productid();
  
  // required string ProductClass = 6;
  inline bool has_productclass() const;
  inline void clear_productclass();
  static const int kProductClassFieldNumber = 6;
  inline const ::std::string& productclass() const;
  inline void set_productclass(const ::std::string& value);
  inline void set_productclass(const char* value);
  inline void set_productclass(const char* value, size_t size);
  inline ::std::string* mutable_productclass();
  inline ::std::string* release_productclass();
  
  // required int32 DeliveryYear = 7;
  inline bool has_deliveryyear() const;
  inline void clear_deliveryyear();
  static const int kDeliveryYearFieldNumber = 7;
  inline ::google::protobuf::int32 deliveryyear() const;
  inline void set_deliveryyear(::google::protobuf::int32 value);
  
  // required int32 DeliveryMonth = 8;
  inline bool has_deliverymonth() const;
  inline void clear_deliverymonth();
  static const int kDeliveryMonthFieldNumber = 8;
  inline ::google::protobuf::int32 deliverymonth() const;
  inline void set_deliverymonth(::google::protobuf::int32 value);
  
  // required int32 MaxMarketOrderVolume = 9;
  inline bool has_maxmarketordervolume() const;
  inline void clear_maxmarketordervolume();
  static const int kMaxMarketOrderVolumeFieldNumber = 9;
  inline ::google::protobuf::int32 maxmarketordervolume() const;
  inline void set_maxmarketordervolume(::google::protobuf::int32 value);
  
  // required int32 MinMarketOrderVolume = 10;
  inline bool has_minmarketordervolume() const;
  inline void clear_minmarketordervolume();
  static const int kMinMarketOrderVolumeFieldNumber = 10;
  inline ::google::protobuf::int32 minmarketordervolume() const;
  inline void set_minmarketordervolume(::google::protobuf::int32 value);
  
  // required int32 MaxLimitOrderVolume = 11;
  inline bool has_maxlimitordervolume() const;
  inline void clear_maxlimitordervolume();
  static const int kMaxLimitOrderVolumeFieldNumber = 11;
  inline ::google::protobuf::int32 maxlimitordervolume() const;
  inline void set_maxlimitordervolume(::google::protobuf::int32 value);
  
  // required int32 MinLimitOrderVolume = 12;
  inline bool has_minlimitordervolume() const;
  inline void clear_minlimitordervolume();
  static const int kMinLimitOrderVolumeFieldNumber = 12;
  inline ::google::protobuf::int32 minlimitordervolume() const;
  inline void set_minlimitordervolume(::google::protobuf::int32 value);
  
  // required int32 VolumeMultiple = 13;
  inline bool has_volumemultiple() const;
  inline void clear_volumemultiple();
  static const int kVolumeMultipleFieldNumber = 13;
  inline ::google::protobuf::int32 volumemultiple() const;
  inline void set_volumemultiple(::google::protobuf::int32 value);
  
  // required double PriceTick = 14;
  inline bool has_pricetick() const;
  inline void clear_pricetick();
  static const int kPriceTickFieldNumber = 14;
  inline double pricetick() const;
  inline void set_pricetick(double value);
  
  // required string CreateDate = 15;
  inline bool has_createdate() const;
  inline void clear_createdate();
  static const int kCreateDateFieldNumber = 15;
  inline const ::std::string& createdate() const;
  inline void set_createdate(const ::std::string& value);
  inline void set_createdate(const char* value);
  inline void set_createdate(const char* value, size_t size);
  inline ::std::string* mutable_createdate();
  inline ::std::string* release_createdate();
  
  // required string OpenDate = 16;
  inline bool has_opendate() const;
  inline void clear_opendate();
  static const int kOpenDateFieldNumber = 16;
  inline const ::std::string& opendate() const;
  inline void set_opendate(const ::std::string& value);
  inline void set_opendate(const char* value);
  inline void set_opendate(const char* value, size_t size);
  inline ::std::string* mutable_opendate();
  inline ::std::string* release_opendate();
  
  // required string ExpireDate = 17;
  inline bool has_expiredate() const;
  inline void clear_expiredate();
  static const int kExpireDateFieldNumber = 17;
  inline const ::std::string& expiredate() const;
  inline void set_expiredate(const ::std::string& value);
  inline void set_expiredate(const char* value);
  inline void set_expiredate(const char* value, size_t size);
  inline ::std::string* mutable_expiredate();
  inline ::std::string* release_expiredate();
  
  // required string StartDelivDate = 18;
  inline bool has_startdelivdate() const;
  inline void clear_startdelivdate();
  static const int kStartDelivDateFieldNumber = 18;
  inline const ::std::string& startdelivdate() const;
  inline void set_startdelivdate(const ::std::string& value);
  inline void set_startdelivdate(const char* value);
  inline void set_startdelivdate(const char* value, size_t size);
  inline ::std::string* mutable_startdelivdate();
  inline ::std::string* release_startdelivdate();
  
  // required string EndDelivDate = 19;
  inline bool has_enddelivdate() const;
  inline void clear_enddelivdate();
  static const int kEndDelivDateFieldNumber = 19;
  inline const ::std::string& enddelivdate() const;
  inline void set_enddelivdate(const ::std::string& value);
  inline void set_enddelivdate(const char* value);
  inline void set_enddelivdate(const char* value, size_t size);
  inline ::std::string* mutable_enddelivdate();
  inline ::std::string* release_enddelivdate();
  
  // required string InstLifePhase = 20;
  inline bool has_instlifephase() const;
  inline void clear_instlifephase();
  static const int kInstLifePhaseFieldNumber = 20;
  inline const ::std::string& instlifephase() const;
  inline void set_instlifephase(const ::std::string& value);
  inline void set_instlifephase(const char* value);
  inline void set_instlifephase(const char* value, size_t size);
  inline ::std::string* mutable_instlifephase();
  inline ::std::string* release_instlifephase();
  
  // required int32 IsTrading = 21;
  inline bool has_istrading() const;
  inline void clear_istrading();
  static const int kIsTradingFieldNumber = 21;
  inline ::google::protobuf::int32 istrading() const;
  inline void set_istrading(::google::protobuf::int32 value);
  
  // required string PositionType = 22;
  inline bool has_positiontype() const;
  inline void clear_positiontype();
  static const int kPositionTypeFieldNumber = 22;
  inline const ::std::string& positiontype() const;
  inline void set_positiontype(const ::std::string& value);
  inline void set_positiontype(const char* value);
  inline void set_positiontype(const char* value, size_t size);
  inline ::std::string* mutable_positiontype();
  inline ::std::string* release_positiontype();
  
  // required string PositionDateType = 23;
  inline bool has_positiondatetype() const;
  inline void clear_positiondatetype();
  static const int kPositionDateTypeFieldNumber = 23;
  inline const ::std::string& positiondatetype() const;
  inline void set_positiondatetype(const ::std::string& value);
  inline void set_positiondatetype(const char* value);
  inline void set_positiondatetype(const char* value, size_t size);
  inline ::std::string* mutable_positiondatetype();
  inline ::std::string* release_positiondatetype();
  
  // required double LongMarginRatio = 24;
  inline bool has_longmarginratio() const;
  inline void clear_longmarginratio();
  static const int kLongMarginRatioFieldNumber = 24;
  inline double longmarginratio() const;
  inline void set_longmarginratio(double value);
  
  // required double ShortMarginRatio = 25;
  inline bool has_shortmarginratio() const;
  inline void clear_shortmarginratio();
  static const int kShortMarginRatioFieldNumber = 25;
  inline double shortmarginratio() const;
  inline void set_shortmarginratio(double value);
  
  // @@protoc_insertion_point(class_scope:FutureTradingPB.MThostFtdcInstrumentField)
 private:
  inline void set_has_instrumentid();
  inline void clear_has_instrumentid();
  inline void set_has_exchangeid();
  inline void clear_has_exchangeid();
  inline void set_has_instrumentname();
  inline void clear_has_instrumentname();
  inline void set_has_exchangeinstid();
  inline void clear_has_exchangeinstid();
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_productclass();
  inline void clear_has_productclass();
  inline void set_has_deliveryyear();
  inline void clear_has_deliveryyear();
  inline void set_has_deliverymonth();
  inline void clear_has_deliverymonth();
  inline void set_has_maxmarketordervolume();
  inline void clear_has_maxmarketordervolume();
  inline void set_has_minmarketordervolume();
  inline void clear_has_minmarketordervolume();
  inline void set_has_maxlimitordervolume();
  inline void clear_has_maxlimitordervolume();
  inline void set_has_minlimitordervolume();
  inline void clear_has_minlimitordervolume();
  inline void set_has_volumemultiple();
  inline void clear_has_volumemultiple();
  inline void set_has_pricetick();
  inline void clear_has_pricetick();
  inline void set_has_createdate();
  inline void clear_has_createdate();
  inline void set_has_opendate();
  inline void clear_has_opendate();
  inline void set_has_expiredate();
  inline void clear_has_expiredate();
  inline void set_has_startdelivdate();
  inline void clear_has_startdelivdate();
  inline void set_has_enddelivdate();
  inline void clear_has_enddelivdate();
  inline void set_has_instlifephase();
  inline void clear_has_instlifephase();
  inline void set_has_istrading();
  inline void clear_has_istrading();
  inline void set_has_positiontype();
  inline void clear_has_positiontype();
  inline void set_has_positiondatetype();
  inline void clear_has_positiondatetype();
  inline void set_has_longmarginratio();
  inline void clear_has_longmarginratio();
  inline void set_has_shortmarginratio();
  inline void clear_has_shortmarginratio();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* instrumentid_;
  ::std::string* exchangeid_;
  ::std::string* instrumentname_;
  ::std::string* exchangeinstid_;
  ::std::string* productid_;
  ::std::string* productclass_;
  ::google::protobuf::int32 deliveryyear_;
  ::google::protobuf::int32 deliverymonth_;
  ::google::protobuf::int32 maxmarketordervolume_;
  ::google::protobuf::int32 minmarketordervolume_;
  ::google::protobuf::int32 maxlimitordervolume_;
  ::google::protobuf::int32 minlimitordervolume_;
  double pricetick_;
  ::std::string* createdate_;
  ::std::string* opendate_;
  ::google::protobuf::int32 volumemultiple_;
  ::google::protobuf::int32 istrading_;
  ::std::string* expiredate_;
  ::std::string* startdelivdate_;
  ::std::string* enddelivdate_;
  ::std::string* instlifephase_;
  ::std::string* positiontype_;
  ::std::string* positiondatetype_;
  double longmarginratio_;
  double shortmarginratio_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];
  
  friend void  protobuf_AddDesc_FutureTrading_2eproto();
  friend void protobuf_AssignDesc_FutureTrading_2eproto();
  friend void protobuf_ShutdownFile_FutureTrading_2eproto();
  
  void InitAsDefaultInstance();
  static MThostFtdcInstrumentField* default_instance_;
};
// ===================================================================


// ===================================================================

// Login

// required string FrontAdd = 1;
inline bool Login::has_frontadd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Login::set_has_frontadd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Login::clear_has_frontadd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Login::clear_frontadd() {
  if (frontadd_ != &::google::protobuf::internal::kEmptyString) {
    frontadd_->clear();
  }
  clear_has_frontadd();
}
inline const ::std::string& Login::frontadd() const {
  return *frontadd_;
}
inline void Login::set_frontadd(const ::std::string& value) {
  set_has_frontadd();
  if (frontadd_ == &::google::protobuf::internal::kEmptyString) {
    frontadd_ = new ::std::string;
  }
  frontadd_->assign(value);
}
inline void Login::set_frontadd(const char* value) {
  set_has_frontadd();
  if (frontadd_ == &::google::protobuf::internal::kEmptyString) {
    frontadd_ = new ::std::string;
  }
  frontadd_->assign(value);
}
inline void Login::set_frontadd(const char* value, size_t size) {
  set_has_frontadd();
  if (frontadd_ == &::google::protobuf::internal::kEmptyString) {
    frontadd_ = new ::std::string;
  }
  frontadd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_frontadd() {
  set_has_frontadd();
  if (frontadd_ == &::google::protobuf::internal::kEmptyString) {
    frontadd_ = new ::std::string;
  }
  return frontadd_;
}
inline ::std::string* Login::release_frontadd() {
  clear_has_frontadd();
  if (frontadd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frontadd_;
    frontadd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string BrokerID = 2;
inline bool Login::has_brokerid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Login::set_has_brokerid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Login::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Login::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& Login::brokerid() const {
  return *brokerid_;
}
inline void Login::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void Login::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void Login::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* Login::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string InvestorID = 3;
inline bool Login::has_investorid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Login::set_has_investorid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Login::clear_has_investorid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Login::clear_investorid() {
  if (investorid_ != &::google::protobuf::internal::kEmptyString) {
    investorid_->clear();
  }
  clear_has_investorid();
}
inline const ::std::string& Login::investorid() const {
  return *investorid_;
}
inline void Login::set_investorid(const ::std::string& value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void Login::set_investorid(const char* value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void Login::set_investorid(const char* value, size_t size) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_investorid() {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  return investorid_;
}
inline ::std::string* Login::release_investorid() {
  clear_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investorid_;
    investorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Password = 4;
inline bool Login::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Login::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Login::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Login::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Login::password() const {
  return *password_;
}
inline void Login::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void Login::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Login::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* Login::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Error

// required int32 ErrorID = 1;
inline bool Error::has_errorid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Error::set_has_errorid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Error::clear_has_errorid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Error::clear_errorid() {
  errorid_ = 0;
  clear_has_errorid();
}
inline ::google::protobuf::int32 Error::errorid() const {
  return errorid_;
}
inline void Error::set_errorid(::google::protobuf::int32 value) {
  set_has_errorid();
  errorid_ = value;
}

// required string ErrorMsg = 2;
inline bool Error::has_errormsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Error::set_has_errormsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Error::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Error::clear_errormsg() {
  if (errormsg_ != &::google::protobuf::internal::kEmptyString) {
    errormsg_->clear();
  }
  clear_has_errormsg();
}
inline const ::std::string& Error::errormsg() const {
  return *errormsg_;
}
inline void Error::set_errormsg(const ::std::string& value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void Error::set_errormsg(const char* value) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(value);
}
inline void Error::set_errormsg(const char* value, size_t size) {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  errormsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Error::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    errormsg_ = new ::std::string;
  }
  return errormsg_;
}
inline ::std::string* Error::release_errormsg() {
  clear_has_errormsg();
  if (errormsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormsg_;
    errormsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// InsertOrder

// required int32 HandleID = 1;
inline bool InsertOrder::has_handleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InsertOrder::set_has_handleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InsertOrder::clear_has_handleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InsertOrder::clear_handleid() {
  handleid_ = 0;
  clear_has_handleid();
}
inline ::google::protobuf::int32 InsertOrder::handleid() const {
  return handleid_;
}
inline void InsertOrder::set_handleid(::google::protobuf::int32 value) {
  set_has_handleid();
  handleid_ = value;
}

// required string InstrumentID = 2;
inline bool InsertOrder::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InsertOrder::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InsertOrder::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InsertOrder::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& InsertOrder::instrumentid() const {
  return *instrumentid_;
}
inline void InsertOrder::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void InsertOrder::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void InsertOrder::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsertOrder::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* InsertOrder::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeID = 3;
inline bool InsertOrder::has_exchangeid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InsertOrder::set_has_exchangeid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InsertOrder::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InsertOrder::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& InsertOrder::exchangeid() const {
  return *exchangeid_;
}
inline void InsertOrder::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void InsertOrder::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void InsertOrder::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsertOrder::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* InsertOrder::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double LimitPrice = 4;
inline bool InsertOrder::has_limitprice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InsertOrder::set_has_limitprice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InsertOrder::clear_has_limitprice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InsertOrder::clear_limitprice() {
  limitprice_ = 0;
  clear_has_limitprice();
}
inline double InsertOrder::limitprice() const {
  return limitprice_;
}
inline void InsertOrder::set_limitprice(double value) {
  set_has_limitprice();
  limitprice_ = value;
}

// required int32 VolumeTotalOriginal = 5;
inline bool InsertOrder::has_volumetotaloriginal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InsertOrder::set_has_volumetotaloriginal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InsertOrder::clear_has_volumetotaloriginal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InsertOrder::clear_volumetotaloriginal() {
  volumetotaloriginal_ = 0;
  clear_has_volumetotaloriginal();
}
inline ::google::protobuf::int32 InsertOrder::volumetotaloriginal() const {
  return volumetotaloriginal_;
}
inline void InsertOrder::set_volumetotaloriginal(::google::protobuf::int32 value) {
  set_has_volumetotaloriginal();
  volumetotaloriginal_ = value;
}

// required string Direction = 6;
inline bool InsertOrder::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InsertOrder::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InsertOrder::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InsertOrder::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& InsertOrder::direction() const {
  return *direction_;
}
inline void InsertOrder::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void InsertOrder::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void InsertOrder::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsertOrder::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* InsertOrder::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string CombOffsetFlag = 7;
inline bool InsertOrder::has_comboffsetflag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InsertOrder::set_has_comboffsetflag() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InsertOrder::clear_has_comboffsetflag() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InsertOrder::clear_comboffsetflag() {
  if (comboffsetflag_ != &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_->clear();
  }
  clear_has_comboffsetflag();
}
inline const ::std::string& InsertOrder::comboffsetflag() const {
  return *comboffsetflag_;
}
inline void InsertOrder::set_comboffsetflag(const ::std::string& value) {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  comboffsetflag_->assign(value);
}
inline void InsertOrder::set_comboffsetflag(const char* value) {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  comboffsetflag_->assign(value);
}
inline void InsertOrder::set_comboffsetflag(const char* value, size_t size) {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  comboffsetflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsertOrder::mutable_comboffsetflag() {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  return comboffsetflag_;
}
inline ::std::string* InsertOrder::release_comboffsetflag() {
  clear_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comboffsetflag_;
    comboffsetflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderPriceType = 8;
inline bool InsertOrder::has_orderpricetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InsertOrder::set_has_orderpricetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InsertOrder::clear_has_orderpricetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InsertOrder::clear_orderpricetype() {
  if (orderpricetype_ != &::google::protobuf::internal::kEmptyString) {
    orderpricetype_->clear();
  }
  clear_has_orderpricetype();
}
inline const ::std::string& InsertOrder::orderpricetype() const {
  return *orderpricetype_;
}
inline void InsertOrder::set_orderpricetype(const ::std::string& value) {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  orderpricetype_->assign(value);
}
inline void InsertOrder::set_orderpricetype(const char* value) {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  orderpricetype_->assign(value);
}
inline void InsertOrder::set_orderpricetype(const char* value, size_t size) {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  orderpricetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InsertOrder::mutable_orderpricetype() {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  return orderpricetype_;
}
inline ::std::string* InsertOrder::release_orderpricetype() {
  clear_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderpricetype_;
    orderpricetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// RtnInsertOrder

// required int32 HandleID = 1;
inline bool RtnInsertOrder::has_handleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtnInsertOrder::set_has_handleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtnInsertOrder::clear_has_handleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtnInsertOrder::clear_handleid() {
  handleid_ = 0;
  clear_has_handleid();
}
inline ::google::protobuf::int32 RtnInsertOrder::handleid() const {
  return handleid_;
}
inline void RtnInsertOrder::set_handleid(::google::protobuf::int32 value) {
  set_has_handleid();
  handleid_ = value;
}

// required int32 Ref = 2;
inline bool RtnInsertOrder::has_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtnInsertOrder::set_has_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtnInsertOrder::clear_has_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtnInsertOrder::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 RtnInsertOrder::ref() const {
  return ref_;
}
inline void RtnInsertOrder::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// required int32 FrontID = 3;
inline bool RtnInsertOrder::has_frontid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtnInsertOrder::set_has_frontid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtnInsertOrder::clear_has_frontid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtnInsertOrder::clear_frontid() {
  frontid_ = 0;
  clear_has_frontid();
}
inline ::google::protobuf::int32 RtnInsertOrder::frontid() const {
  return frontid_;
}
inline void RtnInsertOrder::set_frontid(::google::protobuf::int32 value) {
  set_has_frontid();
  frontid_ = value;
}

// required int32 SessionID = 4;
inline bool RtnInsertOrder::has_sessionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtnInsertOrder::set_has_sessionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtnInsertOrder::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtnInsertOrder::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 RtnInsertOrder::sessionid() const {
  return sessionid_;
}
inline void RtnInsertOrder::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// repeated .FutureTradingPB.MThostFtdcOrderField LastOrder = 5;
inline int RtnInsertOrder::lastorder_size() const {
  return lastorder_.size();
}
inline void RtnInsertOrder::clear_lastorder() {
  lastorder_.Clear();
}
inline const ::FutureTradingPB::MThostFtdcOrderField& RtnInsertOrder::lastorder(int index) const {
  return lastorder_.Get(index);
}
inline ::FutureTradingPB::MThostFtdcOrderField* RtnInsertOrder::mutable_lastorder(int index) {
  return lastorder_.Mutable(index);
}
inline ::FutureTradingPB::MThostFtdcOrderField* RtnInsertOrder::add_lastorder() {
  return lastorder_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >&
RtnInsertOrder::lastorder() const {
  return lastorder_;
}
inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >*
RtnInsertOrder::mutable_lastorder() {
  return &lastorder_;
}

// -------------------------------------------------------------------

// WaitInsertOrder

// required int32 HandleID = 1;
inline bool WaitInsertOrder::has_handleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaitInsertOrder::set_has_handleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaitInsertOrder::clear_has_handleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaitInsertOrder::clear_handleid() {
  handleid_ = 0;
  clear_has_handleid();
}
inline ::google::protobuf::int32 WaitInsertOrder::handleid() const {
  return handleid_;
}
inline void WaitInsertOrder::set_handleid(::google::protobuf::int32 value) {
  set_has_handleid();
  handleid_ = value;
}

// required int32 Ref = 2;
inline bool WaitInsertOrder::has_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WaitInsertOrder::set_has_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WaitInsertOrder::clear_has_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WaitInsertOrder::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 WaitInsertOrder::ref() const {
  return ref_;
}
inline void WaitInsertOrder::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// required int32 FrontID = 3;
inline bool WaitInsertOrder::has_frontid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WaitInsertOrder::set_has_frontid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WaitInsertOrder::clear_has_frontid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WaitInsertOrder::clear_frontid() {
  frontid_ = 0;
  clear_has_frontid();
}
inline ::google::protobuf::int32 WaitInsertOrder::frontid() const {
  return frontid_;
}
inline void WaitInsertOrder::set_frontid(::google::protobuf::int32 value) {
  set_has_frontid();
  frontid_ = value;
}

// required int32 SessionID = 4;
inline bool WaitInsertOrder::has_sessionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WaitInsertOrder::set_has_sessionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WaitInsertOrder::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WaitInsertOrder::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 WaitInsertOrder::sessionid() const {
  return sessionid_;
}
inline void WaitInsertOrder::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// ReqBuffInfo

// required int32 HandleID = 1;
inline bool ReqBuffInfo::has_handleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqBuffInfo::set_has_handleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqBuffInfo::clear_has_handleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqBuffInfo::clear_handleid() {
  handleid_ = 0;
  clear_has_handleid();
}
inline ::google::protobuf::int32 ReqBuffInfo::handleid() const {
  return handleid_;
}
inline void ReqBuffInfo::set_handleid(::google::protobuf::int32 value) {
  set_has_handleid();
  handleid_ = value;
}

// required int32 Ref = 2;
inline bool ReqBuffInfo::has_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqBuffInfo::set_has_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqBuffInfo::clear_has_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqBuffInfo::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 ReqBuffInfo::ref() const {
  return ref_;
}
inline void ReqBuffInfo::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// required int32 FrontID = 3;
inline bool ReqBuffInfo::has_frontid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqBuffInfo::set_has_frontid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqBuffInfo::clear_has_frontid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqBuffInfo::clear_frontid() {
  frontid_ = 0;
  clear_has_frontid();
}
inline ::google::protobuf::int32 ReqBuffInfo::frontid() const {
  return frontid_;
}
inline void ReqBuffInfo::set_frontid(::google::protobuf::int32 value) {
  set_has_frontid();
  frontid_ = value;
}

// required int32 SessionID = 4;
inline bool ReqBuffInfo::has_sessionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqBuffInfo::set_has_sessionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqBuffInfo::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqBuffInfo::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 ReqBuffInfo::sessionid() const {
  return sessionid_;
}
inline void ReqBuffInfo::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// -------------------------------------------------------------------

// RtnTradedInfo

// required int32 HandleID = 1;
inline bool RtnTradedInfo::has_handleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RtnTradedInfo::set_has_handleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RtnTradedInfo::clear_has_handleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RtnTradedInfo::clear_handleid() {
  handleid_ = 0;
  clear_has_handleid();
}
inline ::google::protobuf::int32 RtnTradedInfo::handleid() const {
  return handleid_;
}
inline void RtnTradedInfo::set_handleid(::google::protobuf::int32 value) {
  set_has_handleid();
  handleid_ = value;
}

// required int32 Ref = 2;
inline bool RtnTradedInfo::has_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RtnTradedInfo::set_has_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RtnTradedInfo::clear_has_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RtnTradedInfo::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 RtnTradedInfo::ref() const {
  return ref_;
}
inline void RtnTradedInfo::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// required int32 FrontID = 3;
inline bool RtnTradedInfo::has_frontid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RtnTradedInfo::set_has_frontid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RtnTradedInfo::clear_has_frontid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RtnTradedInfo::clear_frontid() {
  frontid_ = 0;
  clear_has_frontid();
}
inline ::google::protobuf::int32 RtnTradedInfo::frontid() const {
  return frontid_;
}
inline void RtnTradedInfo::set_frontid(::google::protobuf::int32 value) {
  set_has_frontid();
  frontid_ = value;
}

// required int32 SessionID = 4;
inline bool RtnTradedInfo::has_sessionid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RtnTradedInfo::set_has_sessionid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RtnTradedInfo::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RtnTradedInfo::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 RtnTradedInfo::sessionid() const {
  return sessionid_;
}
inline void RtnTradedInfo::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// repeated .FutureTradingPB.MThostFtdcOrderField LastOrder = 5;
inline int RtnTradedInfo::lastorder_size() const {
  return lastorder_.size();
}
inline void RtnTradedInfo::clear_lastorder() {
  lastorder_.Clear();
}
inline const ::FutureTradingPB::MThostFtdcOrderField& RtnTradedInfo::lastorder(int index) const {
  return lastorder_.Get(index);
}
inline ::FutureTradingPB::MThostFtdcOrderField* RtnTradedInfo::mutable_lastorder(int index) {
  return lastorder_.Mutable(index);
}
inline ::FutureTradingPB::MThostFtdcOrderField* RtnTradedInfo::add_lastorder() {
  return lastorder_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >&
RtnTradedInfo::lastorder() const {
  return lastorder_;
}
inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcOrderField >*
RtnTradedInfo::mutable_lastorder() {
  return &lastorder_;
}

// repeated .FutureTradingPB.MThostFtdcTradeField LastTrade = 6;
inline int RtnTradedInfo::lasttrade_size() const {
  return lasttrade_.size();
}
inline void RtnTradedInfo::clear_lasttrade() {
  lasttrade_.Clear();
}
inline const ::FutureTradingPB::MThostFtdcTradeField& RtnTradedInfo::lasttrade(int index) const {
  return lasttrade_.Get(index);
}
inline ::FutureTradingPB::MThostFtdcTradeField* RtnTradedInfo::mutable_lasttrade(int index) {
  return lasttrade_.Mutable(index);
}
inline ::FutureTradingPB::MThostFtdcTradeField* RtnTradedInfo::add_lasttrade() {
  return lasttrade_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcTradeField >&
RtnTradedInfo::lasttrade() const {
  return lasttrade_;
}
inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcTradeField >*
RtnTradedInfo::mutable_lasttrade() {
  return &lasttrade_;
}

// -------------------------------------------------------------------

// RtnAllTradedInfo

// repeated .FutureTradingPB.RtnTradedInfo AllTradedInfo = 1;
inline int RtnAllTradedInfo::alltradedinfo_size() const {
  return alltradedinfo_.size();
}
inline void RtnAllTradedInfo::clear_alltradedinfo() {
  alltradedinfo_.Clear();
}
inline const ::FutureTradingPB::RtnTradedInfo& RtnAllTradedInfo::alltradedinfo(int index) const {
  return alltradedinfo_.Get(index);
}
inline ::FutureTradingPB::RtnTradedInfo* RtnAllTradedInfo::mutable_alltradedinfo(int index) {
  return alltradedinfo_.Mutable(index);
}
inline ::FutureTradingPB::RtnTradedInfo* RtnAllTradedInfo::add_alltradedinfo() {
  return alltradedinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::RtnTradedInfo >&
RtnAllTradedInfo::alltradedinfo() const {
  return alltradedinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::RtnTradedInfo >*
RtnAllTradedInfo::mutable_alltradedinfo() {
  return &alltradedinfo_;
}

// -------------------------------------------------------------------

// MThostFtdcOrderField

// required string InstrumentID = 1;
inline bool MThostFtdcOrderField::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MThostFtdcOrderField::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MThostFtdcOrderField::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MThostFtdcOrderField::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& MThostFtdcOrderField::instrumentid() const {
  return *instrumentid_;
}
inline void MThostFtdcOrderField::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcOrderField::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcOrderField::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* MThostFtdcOrderField::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderRef = 2;
inline bool MThostFtdcOrderField::has_orderref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MThostFtdcOrderField::set_has_orderref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MThostFtdcOrderField::clear_has_orderref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MThostFtdcOrderField::clear_orderref() {
  if (orderref_ != &::google::protobuf::internal::kEmptyString) {
    orderref_->clear();
  }
  clear_has_orderref();
}
inline const ::std::string& MThostFtdcOrderField::orderref() const {
  return *orderref_;
}
inline void MThostFtdcOrderField::set_orderref(const ::std::string& value) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(value);
}
inline void MThostFtdcOrderField::set_orderref(const char* value) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(value);
}
inline void MThostFtdcOrderField::set_orderref(const char* value, size_t size) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_orderref() {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  return orderref_;
}
inline ::std::string* MThostFtdcOrderField::release_orderref() {
  clear_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderref_;
    orderref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderPriceType = 3;
inline bool MThostFtdcOrderField::has_orderpricetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MThostFtdcOrderField::set_has_orderpricetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MThostFtdcOrderField::clear_has_orderpricetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MThostFtdcOrderField::clear_orderpricetype() {
  if (orderpricetype_ != &::google::protobuf::internal::kEmptyString) {
    orderpricetype_->clear();
  }
  clear_has_orderpricetype();
}
inline const ::std::string& MThostFtdcOrderField::orderpricetype() const {
  return *orderpricetype_;
}
inline void MThostFtdcOrderField::set_orderpricetype(const ::std::string& value) {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  orderpricetype_->assign(value);
}
inline void MThostFtdcOrderField::set_orderpricetype(const char* value) {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  orderpricetype_->assign(value);
}
inline void MThostFtdcOrderField::set_orderpricetype(const char* value, size_t size) {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  orderpricetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_orderpricetype() {
  set_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    orderpricetype_ = new ::std::string;
  }
  return orderpricetype_;
}
inline ::std::string* MThostFtdcOrderField::release_orderpricetype() {
  clear_has_orderpricetype();
  if (orderpricetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderpricetype_;
    orderpricetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Direction = 4;
inline bool MThostFtdcOrderField::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MThostFtdcOrderField::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MThostFtdcOrderField::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MThostFtdcOrderField::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& MThostFtdcOrderField::direction() const {
  return *direction_;
}
inline void MThostFtdcOrderField::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void MThostFtdcOrderField::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void MThostFtdcOrderField::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* MThostFtdcOrderField::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string CombOffsetFlag = 5;
inline bool MThostFtdcOrderField::has_comboffsetflag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MThostFtdcOrderField::set_has_comboffsetflag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MThostFtdcOrderField::clear_has_comboffsetflag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MThostFtdcOrderField::clear_comboffsetflag() {
  if (comboffsetflag_ != &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_->clear();
  }
  clear_has_comboffsetflag();
}
inline const ::std::string& MThostFtdcOrderField::comboffsetflag() const {
  return *comboffsetflag_;
}
inline void MThostFtdcOrderField::set_comboffsetflag(const ::std::string& value) {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  comboffsetflag_->assign(value);
}
inline void MThostFtdcOrderField::set_comboffsetflag(const char* value) {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  comboffsetflag_->assign(value);
}
inline void MThostFtdcOrderField::set_comboffsetflag(const char* value, size_t size) {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  comboffsetflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_comboffsetflag() {
  set_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    comboffsetflag_ = new ::std::string;
  }
  return comboffsetflag_;
}
inline ::std::string* MThostFtdcOrderField::release_comboffsetflag() {
  clear_has_comboffsetflag();
  if (comboffsetflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comboffsetflag_;
    comboffsetflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string CombHedgeFlag = 6;
inline bool MThostFtdcOrderField::has_combhedgeflag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MThostFtdcOrderField::set_has_combhedgeflag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MThostFtdcOrderField::clear_has_combhedgeflag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MThostFtdcOrderField::clear_combhedgeflag() {
  if (combhedgeflag_ != &::google::protobuf::internal::kEmptyString) {
    combhedgeflag_->clear();
  }
  clear_has_combhedgeflag();
}
inline const ::std::string& MThostFtdcOrderField::combhedgeflag() const {
  return *combhedgeflag_;
}
inline void MThostFtdcOrderField::set_combhedgeflag(const ::std::string& value) {
  set_has_combhedgeflag();
  if (combhedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    combhedgeflag_ = new ::std::string;
  }
  combhedgeflag_->assign(value);
}
inline void MThostFtdcOrderField::set_combhedgeflag(const char* value) {
  set_has_combhedgeflag();
  if (combhedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    combhedgeflag_ = new ::std::string;
  }
  combhedgeflag_->assign(value);
}
inline void MThostFtdcOrderField::set_combhedgeflag(const char* value, size_t size) {
  set_has_combhedgeflag();
  if (combhedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    combhedgeflag_ = new ::std::string;
  }
  combhedgeflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_combhedgeflag() {
  set_has_combhedgeflag();
  if (combhedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    combhedgeflag_ = new ::std::string;
  }
  return combhedgeflag_;
}
inline ::std::string* MThostFtdcOrderField::release_combhedgeflag() {
  clear_has_combhedgeflag();
  if (combhedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = combhedgeflag_;
    combhedgeflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double LimitPrice = 7;
inline bool MThostFtdcOrderField::has_limitprice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MThostFtdcOrderField::set_has_limitprice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MThostFtdcOrderField::clear_has_limitprice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MThostFtdcOrderField::clear_limitprice() {
  limitprice_ = 0;
  clear_has_limitprice();
}
inline double MThostFtdcOrderField::limitprice() const {
  return limitprice_;
}
inline void MThostFtdcOrderField::set_limitprice(double value) {
  set_has_limitprice();
  limitprice_ = value;
}

// required int32 VolumeTotalOriginal = 8;
inline bool MThostFtdcOrderField::has_volumetotaloriginal() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MThostFtdcOrderField::set_has_volumetotaloriginal() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MThostFtdcOrderField::clear_has_volumetotaloriginal() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MThostFtdcOrderField::clear_volumetotaloriginal() {
  volumetotaloriginal_ = 0;
  clear_has_volumetotaloriginal();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::volumetotaloriginal() const {
  return volumetotaloriginal_;
}
inline void MThostFtdcOrderField::set_volumetotaloriginal(::google::protobuf::int32 value) {
  set_has_volumetotaloriginal();
  volumetotaloriginal_ = value;
}

// required string TimeCondition = 9;
inline bool MThostFtdcOrderField::has_timecondition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MThostFtdcOrderField::set_has_timecondition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MThostFtdcOrderField::clear_has_timecondition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MThostFtdcOrderField::clear_timecondition() {
  if (timecondition_ != &::google::protobuf::internal::kEmptyString) {
    timecondition_->clear();
  }
  clear_has_timecondition();
}
inline const ::std::string& MThostFtdcOrderField::timecondition() const {
  return *timecondition_;
}
inline void MThostFtdcOrderField::set_timecondition(const ::std::string& value) {
  set_has_timecondition();
  if (timecondition_ == &::google::protobuf::internal::kEmptyString) {
    timecondition_ = new ::std::string;
  }
  timecondition_->assign(value);
}
inline void MThostFtdcOrderField::set_timecondition(const char* value) {
  set_has_timecondition();
  if (timecondition_ == &::google::protobuf::internal::kEmptyString) {
    timecondition_ = new ::std::string;
  }
  timecondition_->assign(value);
}
inline void MThostFtdcOrderField::set_timecondition(const char* value, size_t size) {
  set_has_timecondition();
  if (timecondition_ == &::google::protobuf::internal::kEmptyString) {
    timecondition_ = new ::std::string;
  }
  timecondition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_timecondition() {
  set_has_timecondition();
  if (timecondition_ == &::google::protobuf::internal::kEmptyString) {
    timecondition_ = new ::std::string;
  }
  return timecondition_;
}
inline ::std::string* MThostFtdcOrderField::release_timecondition() {
  clear_has_timecondition();
  if (timecondition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timecondition_;
    timecondition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string GTDDate = 10;
inline bool MThostFtdcOrderField::has_gtddate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MThostFtdcOrderField::set_has_gtddate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MThostFtdcOrderField::clear_has_gtddate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MThostFtdcOrderField::clear_gtddate() {
  if (gtddate_ != &::google::protobuf::internal::kEmptyString) {
    gtddate_->clear();
  }
  clear_has_gtddate();
}
inline const ::std::string& MThostFtdcOrderField::gtddate() const {
  return *gtddate_;
}
inline void MThostFtdcOrderField::set_gtddate(const ::std::string& value) {
  set_has_gtddate();
  if (gtddate_ == &::google::protobuf::internal::kEmptyString) {
    gtddate_ = new ::std::string;
  }
  gtddate_->assign(value);
}
inline void MThostFtdcOrderField::set_gtddate(const char* value) {
  set_has_gtddate();
  if (gtddate_ == &::google::protobuf::internal::kEmptyString) {
    gtddate_ = new ::std::string;
  }
  gtddate_->assign(value);
}
inline void MThostFtdcOrderField::set_gtddate(const char* value, size_t size) {
  set_has_gtddate();
  if (gtddate_ == &::google::protobuf::internal::kEmptyString) {
    gtddate_ = new ::std::string;
  }
  gtddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_gtddate() {
  set_has_gtddate();
  if (gtddate_ == &::google::protobuf::internal::kEmptyString) {
    gtddate_ = new ::std::string;
  }
  return gtddate_;
}
inline ::std::string* MThostFtdcOrderField::release_gtddate() {
  clear_has_gtddate();
  if (gtddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gtddate_;
    gtddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 RequestID = 11;
inline bool MThostFtdcOrderField::has_requestid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MThostFtdcOrderField::set_has_requestid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MThostFtdcOrderField::clear_has_requestid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MThostFtdcOrderField::clear_requestid() {
  requestid_ = 0;
  clear_has_requestid();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::requestid() const {
  return requestid_;
}
inline void MThostFtdcOrderField::set_requestid(::google::protobuf::int32 value) {
  set_has_requestid();
  requestid_ = value;
}

// required string OrderLocalID = 12;
inline bool MThostFtdcOrderField::has_orderlocalid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MThostFtdcOrderField::set_has_orderlocalid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MThostFtdcOrderField::clear_has_orderlocalid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MThostFtdcOrderField::clear_orderlocalid() {
  if (orderlocalid_ != &::google::protobuf::internal::kEmptyString) {
    orderlocalid_->clear();
  }
  clear_has_orderlocalid();
}
inline const ::std::string& MThostFtdcOrderField::orderlocalid() const {
  return *orderlocalid_;
}
inline void MThostFtdcOrderField::set_orderlocalid(const ::std::string& value) {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  orderlocalid_->assign(value);
}
inline void MThostFtdcOrderField::set_orderlocalid(const char* value) {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  orderlocalid_->assign(value);
}
inline void MThostFtdcOrderField::set_orderlocalid(const char* value, size_t size) {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  orderlocalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_orderlocalid() {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  return orderlocalid_;
}
inline ::std::string* MThostFtdcOrderField::release_orderlocalid() {
  clear_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderlocalid_;
    orderlocalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeID = 13;
inline bool MThostFtdcOrderField::has_exchangeid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MThostFtdcOrderField::set_has_exchangeid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MThostFtdcOrderField::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MThostFtdcOrderField::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& MThostFtdcOrderField::exchangeid() const {
  return *exchangeid_;
}
inline void MThostFtdcOrderField::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void MThostFtdcOrderField::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void MThostFtdcOrderField::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* MThostFtdcOrderField::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeInstID = 14;
inline bool MThostFtdcOrderField::has_exchangeinstid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MThostFtdcOrderField::set_has_exchangeinstid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MThostFtdcOrderField::clear_has_exchangeinstid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MThostFtdcOrderField::clear_exchangeinstid() {
  if (exchangeinstid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_->clear();
  }
  clear_has_exchangeinstid();
}
inline const ::std::string& MThostFtdcOrderField::exchangeinstid() const {
  return *exchangeinstid_;
}
inline void MThostFtdcOrderField::set_exchangeinstid(const ::std::string& value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void MThostFtdcOrderField::set_exchangeinstid(const char* value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void MThostFtdcOrderField::set_exchangeinstid(const char* value, size_t size) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_exchangeinstid() {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  return exchangeinstid_;
}
inline ::std::string* MThostFtdcOrderField::release_exchangeinstid() {
  clear_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeinstid_;
    exchangeinstid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderSubmitStatus = 15;
inline bool MThostFtdcOrderField::has_ordersubmitstatus() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MThostFtdcOrderField::set_has_ordersubmitstatus() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MThostFtdcOrderField::clear_has_ordersubmitstatus() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MThostFtdcOrderField::clear_ordersubmitstatus() {
  if (ordersubmitstatus_ != &::google::protobuf::internal::kEmptyString) {
    ordersubmitstatus_->clear();
  }
  clear_has_ordersubmitstatus();
}
inline const ::std::string& MThostFtdcOrderField::ordersubmitstatus() const {
  return *ordersubmitstatus_;
}
inline void MThostFtdcOrderField::set_ordersubmitstatus(const ::std::string& value) {
  set_has_ordersubmitstatus();
  if (ordersubmitstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordersubmitstatus_ = new ::std::string;
  }
  ordersubmitstatus_->assign(value);
}
inline void MThostFtdcOrderField::set_ordersubmitstatus(const char* value) {
  set_has_ordersubmitstatus();
  if (ordersubmitstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordersubmitstatus_ = new ::std::string;
  }
  ordersubmitstatus_->assign(value);
}
inline void MThostFtdcOrderField::set_ordersubmitstatus(const char* value, size_t size) {
  set_has_ordersubmitstatus();
  if (ordersubmitstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordersubmitstatus_ = new ::std::string;
  }
  ordersubmitstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_ordersubmitstatus() {
  set_has_ordersubmitstatus();
  if (ordersubmitstatus_ == &::google::protobuf::internal::kEmptyString) {
    ordersubmitstatus_ = new ::std::string;
  }
  return ordersubmitstatus_;
}
inline ::std::string* MThostFtdcOrderField::release_ordersubmitstatus() {
  clear_has_ordersubmitstatus();
  if (ordersubmitstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersubmitstatus_;
    ordersubmitstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 NotifySequence = 16;
inline bool MThostFtdcOrderField::has_notifysequence() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MThostFtdcOrderField::set_has_notifysequence() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MThostFtdcOrderField::clear_has_notifysequence() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MThostFtdcOrderField::clear_notifysequence() {
  notifysequence_ = 0;
  clear_has_notifysequence();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::notifysequence() const {
  return notifysequence_;
}
inline void MThostFtdcOrderField::set_notifysequence(::google::protobuf::int32 value) {
  set_has_notifysequence();
  notifysequence_ = value;
}

// required string TradingDay = 17;
inline bool MThostFtdcOrderField::has_tradingday() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MThostFtdcOrderField::set_has_tradingday() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MThostFtdcOrderField::clear_has_tradingday() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MThostFtdcOrderField::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& MThostFtdcOrderField::tradingday() const {
  return *tradingday_;
}
inline void MThostFtdcOrderField::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcOrderField::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcOrderField::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* MThostFtdcOrderField::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SettlementID = 18;
inline bool MThostFtdcOrderField::has_settlementid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MThostFtdcOrderField::set_has_settlementid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MThostFtdcOrderField::clear_has_settlementid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MThostFtdcOrderField::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::settlementid() const {
  return settlementid_;
}
inline void MThostFtdcOrderField::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required string OrderSysID = 19;
inline bool MThostFtdcOrderField::has_ordersysid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MThostFtdcOrderField::set_has_ordersysid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MThostFtdcOrderField::clear_has_ordersysid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MThostFtdcOrderField::clear_ordersysid() {
  if (ordersysid_ != &::google::protobuf::internal::kEmptyString) {
    ordersysid_->clear();
  }
  clear_has_ordersysid();
}
inline const ::std::string& MThostFtdcOrderField::ordersysid() const {
  return *ordersysid_;
}
inline void MThostFtdcOrderField::set_ordersysid(const ::std::string& value) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(value);
}
inline void MThostFtdcOrderField::set_ordersysid(const char* value) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(value);
}
inline void MThostFtdcOrderField::set_ordersysid(const char* value, size_t size) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_ordersysid() {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  return ordersysid_;
}
inline ::std::string* MThostFtdcOrderField::release_ordersysid() {
  clear_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersysid_;
    ordersysid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderSource = 20;
inline bool MThostFtdcOrderField::has_ordersource() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MThostFtdcOrderField::set_has_ordersource() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MThostFtdcOrderField::clear_has_ordersource() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MThostFtdcOrderField::clear_ordersource() {
  if (ordersource_ != &::google::protobuf::internal::kEmptyString) {
    ordersource_->clear();
  }
  clear_has_ordersource();
}
inline const ::std::string& MThostFtdcOrderField::ordersource() const {
  return *ordersource_;
}
inline void MThostFtdcOrderField::set_ordersource(const ::std::string& value) {
  set_has_ordersource();
  if (ordersource_ == &::google::protobuf::internal::kEmptyString) {
    ordersource_ = new ::std::string;
  }
  ordersource_->assign(value);
}
inline void MThostFtdcOrderField::set_ordersource(const char* value) {
  set_has_ordersource();
  if (ordersource_ == &::google::protobuf::internal::kEmptyString) {
    ordersource_ = new ::std::string;
  }
  ordersource_->assign(value);
}
inline void MThostFtdcOrderField::set_ordersource(const char* value, size_t size) {
  set_has_ordersource();
  if (ordersource_ == &::google::protobuf::internal::kEmptyString) {
    ordersource_ = new ::std::string;
  }
  ordersource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_ordersource() {
  set_has_ordersource();
  if (ordersource_ == &::google::protobuf::internal::kEmptyString) {
    ordersource_ = new ::std::string;
  }
  return ordersource_;
}
inline ::std::string* MThostFtdcOrderField::release_ordersource() {
  clear_has_ordersource();
  if (ordersource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersource_;
    ordersource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderStatus = 21;
inline bool MThostFtdcOrderField::has_orderstatus() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MThostFtdcOrderField::set_has_orderstatus() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MThostFtdcOrderField::clear_has_orderstatus() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MThostFtdcOrderField::clear_orderstatus() {
  if (orderstatus_ != &::google::protobuf::internal::kEmptyString) {
    orderstatus_->clear();
  }
  clear_has_orderstatus();
}
inline const ::std::string& MThostFtdcOrderField::orderstatus() const {
  return *orderstatus_;
}
inline void MThostFtdcOrderField::set_orderstatus(const ::std::string& value) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::kEmptyString) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(value);
}
inline void MThostFtdcOrderField::set_orderstatus(const char* value) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::kEmptyString) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(value);
}
inline void MThostFtdcOrderField::set_orderstatus(const char* value, size_t size) {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::kEmptyString) {
    orderstatus_ = new ::std::string;
  }
  orderstatus_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_orderstatus() {
  set_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::kEmptyString) {
    orderstatus_ = new ::std::string;
  }
  return orderstatus_;
}
inline ::std::string* MThostFtdcOrderField::release_orderstatus() {
  clear_has_orderstatus();
  if (orderstatus_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderstatus_;
    orderstatus_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderType = 22;
inline bool MThostFtdcOrderField::has_ordertype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MThostFtdcOrderField::set_has_ordertype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MThostFtdcOrderField::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MThostFtdcOrderField::clear_ordertype() {
  if (ordertype_ != &::google::protobuf::internal::kEmptyString) {
    ordertype_->clear();
  }
  clear_has_ordertype();
}
inline const ::std::string& MThostFtdcOrderField::ordertype() const {
  return *ordertype_;
}
inline void MThostFtdcOrderField::set_ordertype(const ::std::string& value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
}
inline void MThostFtdcOrderField::set_ordertype(const char* value) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(value);
}
inline void MThostFtdcOrderField::set_ordertype(const char* value, size_t size) {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  ordertype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_ordertype() {
  set_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    ordertype_ = new ::std::string;
  }
  return ordertype_;
}
inline ::std::string* MThostFtdcOrderField::release_ordertype() {
  clear_has_ordertype();
  if (ordertype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordertype_;
    ordertype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 VolumeTraded = 23;
inline bool MThostFtdcOrderField::has_volumetraded() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MThostFtdcOrderField::set_has_volumetraded() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MThostFtdcOrderField::clear_has_volumetraded() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MThostFtdcOrderField::clear_volumetraded() {
  volumetraded_ = 0;
  clear_has_volumetraded();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::volumetraded() const {
  return volumetraded_;
}
inline void MThostFtdcOrderField::set_volumetraded(::google::protobuf::int32 value) {
  set_has_volumetraded();
  volumetraded_ = value;
}

// required int32 VolumeTotal = 24;
inline bool MThostFtdcOrderField::has_volumetotal() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MThostFtdcOrderField::set_has_volumetotal() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MThostFtdcOrderField::clear_has_volumetotal() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MThostFtdcOrderField::clear_volumetotal() {
  volumetotal_ = 0;
  clear_has_volumetotal();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::volumetotal() const {
  return volumetotal_;
}
inline void MThostFtdcOrderField::set_volumetotal(::google::protobuf::int32 value) {
  set_has_volumetotal();
  volumetotal_ = value;
}

// required string InsertDate = 25;
inline bool MThostFtdcOrderField::has_insertdate() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_insertdate() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MThostFtdcOrderField::clear_has_insertdate() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MThostFtdcOrderField::clear_insertdate() {
  if (insertdate_ != &::google::protobuf::internal::kEmptyString) {
    insertdate_->clear();
  }
  clear_has_insertdate();
}
inline const ::std::string& MThostFtdcOrderField::insertdate() const {
  return *insertdate_;
}
inline void MThostFtdcOrderField::set_insertdate(const ::std::string& value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::kEmptyString) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
}
inline void MThostFtdcOrderField::set_insertdate(const char* value) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::kEmptyString) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(value);
}
inline void MThostFtdcOrderField::set_insertdate(const char* value, size_t size) {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::kEmptyString) {
    insertdate_ = new ::std::string;
  }
  insertdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_insertdate() {
  set_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::kEmptyString) {
    insertdate_ = new ::std::string;
  }
  return insertdate_;
}
inline ::std::string* MThostFtdcOrderField::release_insertdate() {
  clear_has_insertdate();
  if (insertdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = insertdate_;
    insertdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string InsertTime = 26;
inline bool MThostFtdcOrderField::has_inserttime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_inserttime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MThostFtdcOrderField::clear_has_inserttime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MThostFtdcOrderField::clear_inserttime() {
  if (inserttime_ != &::google::protobuf::internal::kEmptyString) {
    inserttime_->clear();
  }
  clear_has_inserttime();
}
inline const ::std::string& MThostFtdcOrderField::inserttime() const {
  return *inserttime_;
}
inline void MThostFtdcOrderField::set_inserttime(const ::std::string& value) {
  set_has_inserttime();
  if (inserttime_ == &::google::protobuf::internal::kEmptyString) {
    inserttime_ = new ::std::string;
  }
  inserttime_->assign(value);
}
inline void MThostFtdcOrderField::set_inserttime(const char* value) {
  set_has_inserttime();
  if (inserttime_ == &::google::protobuf::internal::kEmptyString) {
    inserttime_ = new ::std::string;
  }
  inserttime_->assign(value);
}
inline void MThostFtdcOrderField::set_inserttime(const char* value, size_t size) {
  set_has_inserttime();
  if (inserttime_ == &::google::protobuf::internal::kEmptyString) {
    inserttime_ = new ::std::string;
  }
  inserttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_inserttime() {
  set_has_inserttime();
  if (inserttime_ == &::google::protobuf::internal::kEmptyString) {
    inserttime_ = new ::std::string;
  }
  return inserttime_;
}
inline ::std::string* MThostFtdcOrderField::release_inserttime() {
  clear_has_inserttime();
  if (inserttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inserttime_;
    inserttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ActiveTime = 27;
inline bool MThostFtdcOrderField::has_activetime() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_activetime() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MThostFtdcOrderField::clear_has_activetime() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MThostFtdcOrderField::clear_activetime() {
  if (activetime_ != &::google::protobuf::internal::kEmptyString) {
    activetime_->clear();
  }
  clear_has_activetime();
}
inline const ::std::string& MThostFtdcOrderField::activetime() const {
  return *activetime_;
}
inline void MThostFtdcOrderField::set_activetime(const ::std::string& value) {
  set_has_activetime();
  if (activetime_ == &::google::protobuf::internal::kEmptyString) {
    activetime_ = new ::std::string;
  }
  activetime_->assign(value);
}
inline void MThostFtdcOrderField::set_activetime(const char* value) {
  set_has_activetime();
  if (activetime_ == &::google::protobuf::internal::kEmptyString) {
    activetime_ = new ::std::string;
  }
  activetime_->assign(value);
}
inline void MThostFtdcOrderField::set_activetime(const char* value, size_t size) {
  set_has_activetime();
  if (activetime_ == &::google::protobuf::internal::kEmptyString) {
    activetime_ = new ::std::string;
  }
  activetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_activetime() {
  set_has_activetime();
  if (activetime_ == &::google::protobuf::internal::kEmptyString) {
    activetime_ = new ::std::string;
  }
  return activetime_;
}
inline ::std::string* MThostFtdcOrderField::release_activetime() {
  clear_has_activetime();
  if (activetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = activetime_;
    activetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string SuspendTime = 28;
inline bool MThostFtdcOrderField::has_suspendtime() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_suspendtime() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MThostFtdcOrderField::clear_has_suspendtime() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MThostFtdcOrderField::clear_suspendtime() {
  if (suspendtime_ != &::google::protobuf::internal::kEmptyString) {
    suspendtime_->clear();
  }
  clear_has_suspendtime();
}
inline const ::std::string& MThostFtdcOrderField::suspendtime() const {
  return *suspendtime_;
}
inline void MThostFtdcOrderField::set_suspendtime(const ::std::string& value) {
  set_has_suspendtime();
  if (suspendtime_ == &::google::protobuf::internal::kEmptyString) {
    suspendtime_ = new ::std::string;
  }
  suspendtime_->assign(value);
}
inline void MThostFtdcOrderField::set_suspendtime(const char* value) {
  set_has_suspendtime();
  if (suspendtime_ == &::google::protobuf::internal::kEmptyString) {
    suspendtime_ = new ::std::string;
  }
  suspendtime_->assign(value);
}
inline void MThostFtdcOrderField::set_suspendtime(const char* value, size_t size) {
  set_has_suspendtime();
  if (suspendtime_ == &::google::protobuf::internal::kEmptyString) {
    suspendtime_ = new ::std::string;
  }
  suspendtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_suspendtime() {
  set_has_suspendtime();
  if (suspendtime_ == &::google::protobuf::internal::kEmptyString) {
    suspendtime_ = new ::std::string;
  }
  return suspendtime_;
}
inline ::std::string* MThostFtdcOrderField::release_suspendtime() {
  clear_has_suspendtime();
  if (suspendtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = suspendtime_;
    suspendtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UpdateTime = 29;
inline bool MThostFtdcOrderField::has_updatetime() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_updatetime() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MThostFtdcOrderField::clear_has_updatetime() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MThostFtdcOrderField::clear_updatetime() {
  if (updatetime_ != &::google::protobuf::internal::kEmptyString) {
    updatetime_->clear();
  }
  clear_has_updatetime();
}
inline const ::std::string& MThostFtdcOrderField::updatetime() const {
  return *updatetime_;
}
inline void MThostFtdcOrderField::set_updatetime(const ::std::string& value) {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::kEmptyString) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(value);
}
inline void MThostFtdcOrderField::set_updatetime(const char* value) {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::kEmptyString) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(value);
}
inline void MThostFtdcOrderField::set_updatetime(const char* value, size_t size) {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::kEmptyString) {
    updatetime_ = new ::std::string;
  }
  updatetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_updatetime() {
  set_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::kEmptyString) {
    updatetime_ = new ::std::string;
  }
  return updatetime_;
}
inline ::std::string* MThostFtdcOrderField::release_updatetime() {
  clear_has_updatetime();
  if (updatetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = updatetime_;
    updatetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string CancelTime = 30;
inline bool MThostFtdcOrderField::has_canceltime() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_canceltime() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MThostFtdcOrderField::clear_has_canceltime() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MThostFtdcOrderField::clear_canceltime() {
  if (canceltime_ != &::google::protobuf::internal::kEmptyString) {
    canceltime_->clear();
  }
  clear_has_canceltime();
}
inline const ::std::string& MThostFtdcOrderField::canceltime() const {
  return *canceltime_;
}
inline void MThostFtdcOrderField::set_canceltime(const ::std::string& value) {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  canceltime_->assign(value);
}
inline void MThostFtdcOrderField::set_canceltime(const char* value) {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  canceltime_->assign(value);
}
inline void MThostFtdcOrderField::set_canceltime(const char* value, size_t size) {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  canceltime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_canceltime() {
  set_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    canceltime_ = new ::std::string;
  }
  return canceltime_;
}
inline ::std::string* MThostFtdcOrderField::release_canceltime() {
  clear_has_canceltime();
  if (canceltime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = canceltime_;
    canceltime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ActiveTraderID = 31;
inline bool MThostFtdcOrderField::has_activetraderid() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_activetraderid() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MThostFtdcOrderField::clear_has_activetraderid() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MThostFtdcOrderField::clear_activetraderid() {
  if (activetraderid_ != &::google::protobuf::internal::kEmptyString) {
    activetraderid_->clear();
  }
  clear_has_activetraderid();
}
inline const ::std::string& MThostFtdcOrderField::activetraderid() const {
  return *activetraderid_;
}
inline void MThostFtdcOrderField::set_activetraderid(const ::std::string& value) {
  set_has_activetraderid();
  if (activetraderid_ == &::google::protobuf::internal::kEmptyString) {
    activetraderid_ = new ::std::string;
  }
  activetraderid_->assign(value);
}
inline void MThostFtdcOrderField::set_activetraderid(const char* value) {
  set_has_activetraderid();
  if (activetraderid_ == &::google::protobuf::internal::kEmptyString) {
    activetraderid_ = new ::std::string;
  }
  activetraderid_->assign(value);
}
inline void MThostFtdcOrderField::set_activetraderid(const char* value, size_t size) {
  set_has_activetraderid();
  if (activetraderid_ == &::google::protobuf::internal::kEmptyString) {
    activetraderid_ = new ::std::string;
  }
  activetraderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_activetraderid() {
  set_has_activetraderid();
  if (activetraderid_ == &::google::protobuf::internal::kEmptyString) {
    activetraderid_ = new ::std::string;
  }
  return activetraderid_;
}
inline ::std::string* MThostFtdcOrderField::release_activetraderid() {
  clear_has_activetraderid();
  if (activetraderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = activetraderid_;
    activetraderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ClearingPartID = 32;
inline bool MThostFtdcOrderField::has_clearingpartid() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MThostFtdcOrderField::set_has_clearingpartid() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MThostFtdcOrderField::clear_has_clearingpartid() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MThostFtdcOrderField::clear_clearingpartid() {
  if (clearingpartid_ != &::google::protobuf::internal::kEmptyString) {
    clearingpartid_->clear();
  }
  clear_has_clearingpartid();
}
inline const ::std::string& MThostFtdcOrderField::clearingpartid() const {
  return *clearingpartid_;
}
inline void MThostFtdcOrderField::set_clearingpartid(const ::std::string& value) {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  clearingpartid_->assign(value);
}
inline void MThostFtdcOrderField::set_clearingpartid(const char* value) {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  clearingpartid_->assign(value);
}
inline void MThostFtdcOrderField::set_clearingpartid(const char* value, size_t size) {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  clearingpartid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_clearingpartid() {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  return clearingpartid_;
}
inline ::std::string* MThostFtdcOrderField::release_clearingpartid() {
  clear_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clearingpartid_;
    clearingpartid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SequenceNo = 33;
inline bool MThostFtdcOrderField::has_sequenceno() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MThostFtdcOrderField::set_has_sequenceno() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MThostFtdcOrderField::clear_has_sequenceno() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MThostFtdcOrderField::clear_sequenceno() {
  sequenceno_ = 0;
  clear_has_sequenceno();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::sequenceno() const {
  return sequenceno_;
}
inline void MThostFtdcOrderField::set_sequenceno(::google::protobuf::int32 value) {
  set_has_sequenceno();
  sequenceno_ = value;
}

// required int32 FrontID = 34;
inline bool MThostFtdcOrderField::has_frontid() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MThostFtdcOrderField::set_has_frontid() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MThostFtdcOrderField::clear_has_frontid() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MThostFtdcOrderField::clear_frontid() {
  frontid_ = 0;
  clear_has_frontid();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::frontid() const {
  return frontid_;
}
inline void MThostFtdcOrderField::set_frontid(::google::protobuf::int32 value) {
  set_has_frontid();
  frontid_ = value;
}

// required int32 SessionID = 35;
inline bool MThostFtdcOrderField::has_sessionid() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MThostFtdcOrderField::set_has_sessionid() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MThostFtdcOrderField::clear_has_sessionid() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MThostFtdcOrderField::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::sessionid() const {
  return sessionid_;
}
inline void MThostFtdcOrderField::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// required string UserProductInfo = 36;
inline bool MThostFtdcOrderField::has_userproductinfo() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MThostFtdcOrderField::set_has_userproductinfo() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MThostFtdcOrderField::clear_has_userproductinfo() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MThostFtdcOrderField::clear_userproductinfo() {
  if (userproductinfo_ != &::google::protobuf::internal::kEmptyString) {
    userproductinfo_->clear();
  }
  clear_has_userproductinfo();
}
inline const ::std::string& MThostFtdcOrderField::userproductinfo() const {
  return *userproductinfo_;
}
inline void MThostFtdcOrderField::set_userproductinfo(const ::std::string& value) {
  set_has_userproductinfo();
  if (userproductinfo_ == &::google::protobuf::internal::kEmptyString) {
    userproductinfo_ = new ::std::string;
  }
  userproductinfo_->assign(value);
}
inline void MThostFtdcOrderField::set_userproductinfo(const char* value) {
  set_has_userproductinfo();
  if (userproductinfo_ == &::google::protobuf::internal::kEmptyString) {
    userproductinfo_ = new ::std::string;
  }
  userproductinfo_->assign(value);
}
inline void MThostFtdcOrderField::set_userproductinfo(const char* value, size_t size) {
  set_has_userproductinfo();
  if (userproductinfo_ == &::google::protobuf::internal::kEmptyString) {
    userproductinfo_ = new ::std::string;
  }
  userproductinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_userproductinfo() {
  set_has_userproductinfo();
  if (userproductinfo_ == &::google::protobuf::internal::kEmptyString) {
    userproductinfo_ = new ::std::string;
  }
  return userproductinfo_;
}
inline ::std::string* MThostFtdcOrderField::release_userproductinfo() {
  clear_has_userproductinfo();
  if (userproductinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userproductinfo_;
    userproductinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StatusMsg = 37;
inline bool MThostFtdcOrderField::has_statusmsg() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MThostFtdcOrderField::set_has_statusmsg() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MThostFtdcOrderField::clear_has_statusmsg() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MThostFtdcOrderField::clear_statusmsg() {
  if (statusmsg_ != &::google::protobuf::internal::kEmptyString) {
    statusmsg_->clear();
  }
  clear_has_statusmsg();
}
inline const ::std::string& MThostFtdcOrderField::statusmsg() const {
  return *statusmsg_;
}
inline void MThostFtdcOrderField::set_statusmsg(const ::std::string& value) {
  set_has_statusmsg();
  if (statusmsg_ == &::google::protobuf::internal::kEmptyString) {
    statusmsg_ = new ::std::string;
  }
  statusmsg_->assign(value);
}
inline void MThostFtdcOrderField::set_statusmsg(const char* value) {
  set_has_statusmsg();
  if (statusmsg_ == &::google::protobuf::internal::kEmptyString) {
    statusmsg_ = new ::std::string;
  }
  statusmsg_->assign(value);
}
inline void MThostFtdcOrderField::set_statusmsg(const char* value, size_t size) {
  set_has_statusmsg();
  if (statusmsg_ == &::google::protobuf::internal::kEmptyString) {
    statusmsg_ = new ::std::string;
  }
  statusmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcOrderField::mutable_statusmsg() {
  set_has_statusmsg();
  if (statusmsg_ == &::google::protobuf::internal::kEmptyString) {
    statusmsg_ = new ::std::string;
  }
  return statusmsg_;
}
inline ::std::string* MThostFtdcOrderField::release_statusmsg() {
  clear_has_statusmsg();
  if (statusmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statusmsg_;
    statusmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 UserForceClose = 38;
inline bool MThostFtdcOrderField::has_userforceclose() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MThostFtdcOrderField::set_has_userforceclose() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MThostFtdcOrderField::clear_has_userforceclose() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MThostFtdcOrderField::clear_userforceclose() {
  userforceclose_ = 0;
  clear_has_userforceclose();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::userforceclose() const {
  return userforceclose_;
}
inline void MThostFtdcOrderField::set_userforceclose(::google::protobuf::int32 value) {
  set_has_userforceclose();
  userforceclose_ = value;
}

// required int32 BrokerOrderSeq = 39;
inline bool MThostFtdcOrderField::has_brokerorderseq() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void MThostFtdcOrderField::set_has_brokerorderseq() {
  _has_bits_[1] |= 0x00000040u;
}
inline void MThostFtdcOrderField::clear_has_brokerorderseq() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void MThostFtdcOrderField::clear_brokerorderseq() {
  brokerorderseq_ = 0;
  clear_has_brokerorderseq();
}
inline ::google::protobuf::int32 MThostFtdcOrderField::brokerorderseq() const {
  return brokerorderseq_;
}
inline void MThostFtdcOrderField::set_brokerorderseq(::google::protobuf::int32 value) {
  set_has_brokerorderseq();
  brokerorderseq_ = value;
}

// -------------------------------------------------------------------

// MThostFtdcTradeField

// required string InstrumentID = 1;
inline bool MThostFtdcTradeField::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MThostFtdcTradeField::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MThostFtdcTradeField::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MThostFtdcTradeField::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& MThostFtdcTradeField::instrumentid() const {
  return *instrumentid_;
}
inline void MThostFtdcTradeField::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcTradeField::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcTradeField::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* MThostFtdcTradeField::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderRef = 2;
inline bool MThostFtdcTradeField::has_orderref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MThostFtdcTradeField::set_has_orderref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MThostFtdcTradeField::clear_has_orderref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MThostFtdcTradeField::clear_orderref() {
  if (orderref_ != &::google::protobuf::internal::kEmptyString) {
    orderref_->clear();
  }
  clear_has_orderref();
}
inline const ::std::string& MThostFtdcTradeField::orderref() const {
  return *orderref_;
}
inline void MThostFtdcTradeField::set_orderref(const ::std::string& value) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(value);
}
inline void MThostFtdcTradeField::set_orderref(const char* value) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(value);
}
inline void MThostFtdcTradeField::set_orderref(const char* value, size_t size) {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  orderref_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_orderref() {
  set_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    orderref_ = new ::std::string;
  }
  return orderref_;
}
inline ::std::string* MThostFtdcTradeField::release_orderref() {
  clear_has_orderref();
  if (orderref_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderref_;
    orderref_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string UserID = 3;
inline bool MThostFtdcTradeField::has_userid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MThostFtdcTradeField::set_has_userid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MThostFtdcTradeField::clear_has_userid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MThostFtdcTradeField::clear_userid() {
  if (userid_ != &::google::protobuf::internal::kEmptyString) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& MThostFtdcTradeField::userid() const {
  return *userid_;
}
inline void MThostFtdcTradeField::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void MThostFtdcTradeField::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void MThostFtdcTradeField::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    userid_ = new ::std::string;
  }
  return userid_;
}
inline ::std::string* MThostFtdcTradeField::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeID = 4;
inline bool MThostFtdcTradeField::has_exchangeid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MThostFtdcTradeField::set_has_exchangeid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MThostFtdcTradeField::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MThostFtdcTradeField::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& MThostFtdcTradeField::exchangeid() const {
  return *exchangeid_;
}
inline void MThostFtdcTradeField::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void MThostFtdcTradeField::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void MThostFtdcTradeField::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* MThostFtdcTradeField::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string TradeID = 5;
inline bool MThostFtdcTradeField::has_tradeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MThostFtdcTradeField::set_has_tradeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MThostFtdcTradeField::clear_has_tradeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MThostFtdcTradeField::clear_tradeid() {
  if (tradeid_ != &::google::protobuf::internal::kEmptyString) {
    tradeid_->clear();
  }
  clear_has_tradeid();
}
inline const ::std::string& MThostFtdcTradeField::tradeid() const {
  return *tradeid_;
}
inline void MThostFtdcTradeField::set_tradeid(const ::std::string& value) {
  set_has_tradeid();
  if (tradeid_ == &::google::protobuf::internal::kEmptyString) {
    tradeid_ = new ::std::string;
  }
  tradeid_->assign(value);
}
inline void MThostFtdcTradeField::set_tradeid(const char* value) {
  set_has_tradeid();
  if (tradeid_ == &::google::protobuf::internal::kEmptyString) {
    tradeid_ = new ::std::string;
  }
  tradeid_->assign(value);
}
inline void MThostFtdcTradeField::set_tradeid(const char* value, size_t size) {
  set_has_tradeid();
  if (tradeid_ == &::google::protobuf::internal::kEmptyString) {
    tradeid_ = new ::std::string;
  }
  tradeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_tradeid() {
  set_has_tradeid();
  if (tradeid_ == &::google::protobuf::internal::kEmptyString) {
    tradeid_ = new ::std::string;
  }
  return tradeid_;
}
inline ::std::string* MThostFtdcTradeField::release_tradeid() {
  clear_has_tradeid();
  if (tradeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradeid_;
    tradeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string Direction = 6;
inline bool MThostFtdcTradeField::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MThostFtdcTradeField::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MThostFtdcTradeField::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MThostFtdcTradeField::clear_direction() {
  if (direction_ != &::google::protobuf::internal::kEmptyString) {
    direction_->clear();
  }
  clear_has_direction();
}
inline const ::std::string& MThostFtdcTradeField::direction() const {
  return *direction_;
}
inline void MThostFtdcTradeField::set_direction(const ::std::string& value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void MThostFtdcTradeField::set_direction(const char* value) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(value);
}
inline void MThostFtdcTradeField::set_direction(const char* value, size_t size) {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  direction_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_direction() {
  set_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    direction_ = new ::std::string;
  }
  return direction_;
}
inline ::std::string* MThostFtdcTradeField::release_direction() {
  clear_has_direction();
  if (direction_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = direction_;
    direction_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderSysID = 7;
inline bool MThostFtdcTradeField::has_ordersysid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MThostFtdcTradeField::set_has_ordersysid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MThostFtdcTradeField::clear_has_ordersysid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MThostFtdcTradeField::clear_ordersysid() {
  if (ordersysid_ != &::google::protobuf::internal::kEmptyString) {
    ordersysid_->clear();
  }
  clear_has_ordersysid();
}
inline const ::std::string& MThostFtdcTradeField::ordersysid() const {
  return *ordersysid_;
}
inline void MThostFtdcTradeField::set_ordersysid(const ::std::string& value) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(value);
}
inline void MThostFtdcTradeField::set_ordersysid(const char* value) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(value);
}
inline void MThostFtdcTradeField::set_ordersysid(const char* value, size_t size) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_ordersysid() {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  return ordersysid_;
}
inline ::std::string* MThostFtdcTradeField::release_ordersysid() {
  clear_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersysid_;
    ordersysid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ParticipantID = 8;
inline bool MThostFtdcTradeField::has_participantid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MThostFtdcTradeField::set_has_participantid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MThostFtdcTradeField::clear_has_participantid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MThostFtdcTradeField::clear_participantid() {
  if (participantid_ != &::google::protobuf::internal::kEmptyString) {
    participantid_->clear();
  }
  clear_has_participantid();
}
inline const ::std::string& MThostFtdcTradeField::participantid() const {
  return *participantid_;
}
inline void MThostFtdcTradeField::set_participantid(const ::std::string& value) {
  set_has_participantid();
  if (participantid_ == &::google::protobuf::internal::kEmptyString) {
    participantid_ = new ::std::string;
  }
  participantid_->assign(value);
}
inline void MThostFtdcTradeField::set_participantid(const char* value) {
  set_has_participantid();
  if (participantid_ == &::google::protobuf::internal::kEmptyString) {
    participantid_ = new ::std::string;
  }
  participantid_->assign(value);
}
inline void MThostFtdcTradeField::set_participantid(const char* value, size_t size) {
  set_has_participantid();
  if (participantid_ == &::google::protobuf::internal::kEmptyString) {
    participantid_ = new ::std::string;
  }
  participantid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_participantid() {
  set_has_participantid();
  if (participantid_ == &::google::protobuf::internal::kEmptyString) {
    participantid_ = new ::std::string;
  }
  return participantid_;
}
inline ::std::string* MThostFtdcTradeField::release_participantid() {
  clear_has_participantid();
  if (participantid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = participantid_;
    participantid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ClientID = 9;
inline bool MThostFtdcTradeField::has_clientid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MThostFtdcTradeField::set_has_clientid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MThostFtdcTradeField::clear_has_clientid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MThostFtdcTradeField::clear_clientid() {
  if (clientid_ != &::google::protobuf::internal::kEmptyString) {
    clientid_->clear();
  }
  clear_has_clientid();
}
inline const ::std::string& MThostFtdcTradeField::clientid() const {
  return *clientid_;
}
inline void MThostFtdcTradeField::set_clientid(const ::std::string& value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
}
inline void MThostFtdcTradeField::set_clientid(const char* value) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(value);
}
inline void MThostFtdcTradeField::set_clientid(const char* value, size_t size) {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  clientid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_clientid() {
  set_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    clientid_ = new ::std::string;
  }
  return clientid_;
}
inline ::std::string* MThostFtdcTradeField::release_clientid() {
  clear_has_clientid();
  if (clientid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clientid_;
    clientid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string TradingRole = 10;
inline bool MThostFtdcTradeField::has_tradingrole() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MThostFtdcTradeField::set_has_tradingrole() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MThostFtdcTradeField::clear_has_tradingrole() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MThostFtdcTradeField::clear_tradingrole() {
  if (tradingrole_ != &::google::protobuf::internal::kEmptyString) {
    tradingrole_->clear();
  }
  clear_has_tradingrole();
}
inline const ::std::string& MThostFtdcTradeField::tradingrole() const {
  return *tradingrole_;
}
inline void MThostFtdcTradeField::set_tradingrole(const ::std::string& value) {
  set_has_tradingrole();
  if (tradingrole_ == &::google::protobuf::internal::kEmptyString) {
    tradingrole_ = new ::std::string;
  }
  tradingrole_->assign(value);
}
inline void MThostFtdcTradeField::set_tradingrole(const char* value) {
  set_has_tradingrole();
  if (tradingrole_ == &::google::protobuf::internal::kEmptyString) {
    tradingrole_ = new ::std::string;
  }
  tradingrole_->assign(value);
}
inline void MThostFtdcTradeField::set_tradingrole(const char* value, size_t size) {
  set_has_tradingrole();
  if (tradingrole_ == &::google::protobuf::internal::kEmptyString) {
    tradingrole_ = new ::std::string;
  }
  tradingrole_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_tradingrole() {
  set_has_tradingrole();
  if (tradingrole_ == &::google::protobuf::internal::kEmptyString) {
    tradingrole_ = new ::std::string;
  }
  return tradingrole_;
}
inline ::std::string* MThostFtdcTradeField::release_tradingrole() {
  clear_has_tradingrole();
  if (tradingrole_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingrole_;
    tradingrole_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeInstID = 11;
inline bool MThostFtdcTradeField::has_exchangeinstid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MThostFtdcTradeField::set_has_exchangeinstid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MThostFtdcTradeField::clear_has_exchangeinstid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MThostFtdcTradeField::clear_exchangeinstid() {
  if (exchangeinstid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_->clear();
  }
  clear_has_exchangeinstid();
}
inline const ::std::string& MThostFtdcTradeField::exchangeinstid() const {
  return *exchangeinstid_;
}
inline void MThostFtdcTradeField::set_exchangeinstid(const ::std::string& value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void MThostFtdcTradeField::set_exchangeinstid(const char* value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void MThostFtdcTradeField::set_exchangeinstid(const char* value, size_t size) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_exchangeinstid() {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  return exchangeinstid_;
}
inline ::std::string* MThostFtdcTradeField::release_exchangeinstid() {
  clear_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeinstid_;
    exchangeinstid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OffsetFlag = 12;
inline bool MThostFtdcTradeField::has_offsetflag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MThostFtdcTradeField::set_has_offsetflag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MThostFtdcTradeField::clear_has_offsetflag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MThostFtdcTradeField::clear_offsetflag() {
  if (offsetflag_ != &::google::protobuf::internal::kEmptyString) {
    offsetflag_->clear();
  }
  clear_has_offsetflag();
}
inline const ::std::string& MThostFtdcTradeField::offsetflag() const {
  return *offsetflag_;
}
inline void MThostFtdcTradeField::set_offsetflag(const ::std::string& value) {
  set_has_offsetflag();
  if (offsetflag_ == &::google::protobuf::internal::kEmptyString) {
    offsetflag_ = new ::std::string;
  }
  offsetflag_->assign(value);
}
inline void MThostFtdcTradeField::set_offsetflag(const char* value) {
  set_has_offsetflag();
  if (offsetflag_ == &::google::protobuf::internal::kEmptyString) {
    offsetflag_ = new ::std::string;
  }
  offsetflag_->assign(value);
}
inline void MThostFtdcTradeField::set_offsetflag(const char* value, size_t size) {
  set_has_offsetflag();
  if (offsetflag_ == &::google::protobuf::internal::kEmptyString) {
    offsetflag_ = new ::std::string;
  }
  offsetflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_offsetflag() {
  set_has_offsetflag();
  if (offsetflag_ == &::google::protobuf::internal::kEmptyString) {
    offsetflag_ = new ::std::string;
  }
  return offsetflag_;
}
inline ::std::string* MThostFtdcTradeField::release_offsetflag() {
  clear_has_offsetflag();
  if (offsetflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = offsetflag_;
    offsetflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string HedgeFlag = 13;
inline bool MThostFtdcTradeField::has_hedgeflag() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MThostFtdcTradeField::set_has_hedgeflag() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MThostFtdcTradeField::clear_has_hedgeflag() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MThostFtdcTradeField::clear_hedgeflag() {
  if (hedgeflag_ != &::google::protobuf::internal::kEmptyString) {
    hedgeflag_->clear();
  }
  clear_has_hedgeflag();
}
inline const ::std::string& MThostFtdcTradeField::hedgeflag() const {
  return *hedgeflag_;
}
inline void MThostFtdcTradeField::set_hedgeflag(const ::std::string& value) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(value);
}
inline void MThostFtdcTradeField::set_hedgeflag(const char* value) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(value);
}
inline void MThostFtdcTradeField::set_hedgeflag(const char* value, size_t size) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_hedgeflag() {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  return hedgeflag_;
}
inline ::std::string* MThostFtdcTradeField::release_hedgeflag() {
  clear_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hedgeflag_;
    hedgeflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double Price = 14;
inline bool MThostFtdcTradeField::has_price() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MThostFtdcTradeField::set_has_price() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MThostFtdcTradeField::clear_has_price() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MThostFtdcTradeField::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline double MThostFtdcTradeField::price() const {
  return price_;
}
inline void MThostFtdcTradeField::set_price(double value) {
  set_has_price();
  price_ = value;
}

// required int32 Volume = 15;
inline bool MThostFtdcTradeField::has_volume() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MThostFtdcTradeField::set_has_volume() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MThostFtdcTradeField::clear_has_volume() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MThostFtdcTradeField::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 MThostFtdcTradeField::volume() const {
  return volume_;
}
inline void MThostFtdcTradeField::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// required string TradeDate = 16;
inline bool MThostFtdcTradeField::has_tradedate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MThostFtdcTradeField::set_has_tradedate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MThostFtdcTradeField::clear_has_tradedate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MThostFtdcTradeField::clear_tradedate() {
  if (tradedate_ != &::google::protobuf::internal::kEmptyString) {
    tradedate_->clear();
  }
  clear_has_tradedate();
}
inline const ::std::string& MThostFtdcTradeField::tradedate() const {
  return *tradedate_;
}
inline void MThostFtdcTradeField::set_tradedate(const ::std::string& value) {
  set_has_tradedate();
  if (tradedate_ == &::google::protobuf::internal::kEmptyString) {
    tradedate_ = new ::std::string;
  }
  tradedate_->assign(value);
}
inline void MThostFtdcTradeField::set_tradedate(const char* value) {
  set_has_tradedate();
  if (tradedate_ == &::google::protobuf::internal::kEmptyString) {
    tradedate_ = new ::std::string;
  }
  tradedate_->assign(value);
}
inline void MThostFtdcTradeField::set_tradedate(const char* value, size_t size) {
  set_has_tradedate();
  if (tradedate_ == &::google::protobuf::internal::kEmptyString) {
    tradedate_ = new ::std::string;
  }
  tradedate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_tradedate() {
  set_has_tradedate();
  if (tradedate_ == &::google::protobuf::internal::kEmptyString) {
    tradedate_ = new ::std::string;
  }
  return tradedate_;
}
inline ::std::string* MThostFtdcTradeField::release_tradedate() {
  clear_has_tradedate();
  if (tradedate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradedate_;
    tradedate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string TradeTime = 17;
inline bool MThostFtdcTradeField::has_tradetime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MThostFtdcTradeField::set_has_tradetime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MThostFtdcTradeField::clear_has_tradetime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MThostFtdcTradeField::clear_tradetime() {
  if (tradetime_ != &::google::protobuf::internal::kEmptyString) {
    tradetime_->clear();
  }
  clear_has_tradetime();
}
inline const ::std::string& MThostFtdcTradeField::tradetime() const {
  return *tradetime_;
}
inline void MThostFtdcTradeField::set_tradetime(const ::std::string& value) {
  set_has_tradetime();
  if (tradetime_ == &::google::protobuf::internal::kEmptyString) {
    tradetime_ = new ::std::string;
  }
  tradetime_->assign(value);
}
inline void MThostFtdcTradeField::set_tradetime(const char* value) {
  set_has_tradetime();
  if (tradetime_ == &::google::protobuf::internal::kEmptyString) {
    tradetime_ = new ::std::string;
  }
  tradetime_->assign(value);
}
inline void MThostFtdcTradeField::set_tradetime(const char* value, size_t size) {
  set_has_tradetime();
  if (tradetime_ == &::google::protobuf::internal::kEmptyString) {
    tradetime_ = new ::std::string;
  }
  tradetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_tradetime() {
  set_has_tradetime();
  if (tradetime_ == &::google::protobuf::internal::kEmptyString) {
    tradetime_ = new ::std::string;
  }
  return tradetime_;
}
inline ::std::string* MThostFtdcTradeField::release_tradetime() {
  clear_has_tradetime();
  if (tradetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradetime_;
    tradetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string TradeType = 18;
inline bool MThostFtdcTradeField::has_tradetype() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MThostFtdcTradeField::set_has_tradetype() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MThostFtdcTradeField::clear_has_tradetype() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MThostFtdcTradeField::clear_tradetype() {
  if (tradetype_ != &::google::protobuf::internal::kEmptyString) {
    tradetype_->clear();
  }
  clear_has_tradetype();
}
inline const ::std::string& MThostFtdcTradeField::tradetype() const {
  return *tradetype_;
}
inline void MThostFtdcTradeField::set_tradetype(const ::std::string& value) {
  set_has_tradetype();
  if (tradetype_ == &::google::protobuf::internal::kEmptyString) {
    tradetype_ = new ::std::string;
  }
  tradetype_->assign(value);
}
inline void MThostFtdcTradeField::set_tradetype(const char* value) {
  set_has_tradetype();
  if (tradetype_ == &::google::protobuf::internal::kEmptyString) {
    tradetype_ = new ::std::string;
  }
  tradetype_->assign(value);
}
inline void MThostFtdcTradeField::set_tradetype(const char* value, size_t size) {
  set_has_tradetype();
  if (tradetype_ == &::google::protobuf::internal::kEmptyString) {
    tradetype_ = new ::std::string;
  }
  tradetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_tradetype() {
  set_has_tradetype();
  if (tradetype_ == &::google::protobuf::internal::kEmptyString) {
    tradetype_ = new ::std::string;
  }
  return tradetype_;
}
inline ::std::string* MThostFtdcTradeField::release_tradetype() {
  clear_has_tradetype();
  if (tradetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradetype_;
    tradetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PriceSource = 19;
inline bool MThostFtdcTradeField::has_pricesource() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MThostFtdcTradeField::set_has_pricesource() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MThostFtdcTradeField::clear_has_pricesource() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MThostFtdcTradeField::clear_pricesource() {
  if (pricesource_ != &::google::protobuf::internal::kEmptyString) {
    pricesource_->clear();
  }
  clear_has_pricesource();
}
inline const ::std::string& MThostFtdcTradeField::pricesource() const {
  return *pricesource_;
}
inline void MThostFtdcTradeField::set_pricesource(const ::std::string& value) {
  set_has_pricesource();
  if (pricesource_ == &::google::protobuf::internal::kEmptyString) {
    pricesource_ = new ::std::string;
  }
  pricesource_->assign(value);
}
inline void MThostFtdcTradeField::set_pricesource(const char* value) {
  set_has_pricesource();
  if (pricesource_ == &::google::protobuf::internal::kEmptyString) {
    pricesource_ = new ::std::string;
  }
  pricesource_->assign(value);
}
inline void MThostFtdcTradeField::set_pricesource(const char* value, size_t size) {
  set_has_pricesource();
  if (pricesource_ == &::google::protobuf::internal::kEmptyString) {
    pricesource_ = new ::std::string;
  }
  pricesource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_pricesource() {
  set_has_pricesource();
  if (pricesource_ == &::google::protobuf::internal::kEmptyString) {
    pricesource_ = new ::std::string;
  }
  return pricesource_;
}
inline ::std::string* MThostFtdcTradeField::release_pricesource() {
  clear_has_pricesource();
  if (pricesource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pricesource_;
    pricesource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string TraderID = 20;
inline bool MThostFtdcTradeField::has_traderid() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MThostFtdcTradeField::set_has_traderid() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MThostFtdcTradeField::clear_has_traderid() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MThostFtdcTradeField::clear_traderid() {
  if (traderid_ != &::google::protobuf::internal::kEmptyString) {
    traderid_->clear();
  }
  clear_has_traderid();
}
inline const ::std::string& MThostFtdcTradeField::traderid() const {
  return *traderid_;
}
inline void MThostFtdcTradeField::set_traderid(const ::std::string& value) {
  set_has_traderid();
  if (traderid_ == &::google::protobuf::internal::kEmptyString) {
    traderid_ = new ::std::string;
  }
  traderid_->assign(value);
}
inline void MThostFtdcTradeField::set_traderid(const char* value) {
  set_has_traderid();
  if (traderid_ == &::google::protobuf::internal::kEmptyString) {
    traderid_ = new ::std::string;
  }
  traderid_->assign(value);
}
inline void MThostFtdcTradeField::set_traderid(const char* value, size_t size) {
  set_has_traderid();
  if (traderid_ == &::google::protobuf::internal::kEmptyString) {
    traderid_ = new ::std::string;
  }
  traderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_traderid() {
  set_has_traderid();
  if (traderid_ == &::google::protobuf::internal::kEmptyString) {
    traderid_ = new ::std::string;
  }
  return traderid_;
}
inline ::std::string* MThostFtdcTradeField::release_traderid() {
  clear_has_traderid();
  if (traderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = traderid_;
    traderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OrderLocalID = 21;
inline bool MThostFtdcTradeField::has_orderlocalid() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MThostFtdcTradeField::set_has_orderlocalid() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MThostFtdcTradeField::clear_has_orderlocalid() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MThostFtdcTradeField::clear_orderlocalid() {
  if (orderlocalid_ != &::google::protobuf::internal::kEmptyString) {
    orderlocalid_->clear();
  }
  clear_has_orderlocalid();
}
inline const ::std::string& MThostFtdcTradeField::orderlocalid() const {
  return *orderlocalid_;
}
inline void MThostFtdcTradeField::set_orderlocalid(const ::std::string& value) {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  orderlocalid_->assign(value);
}
inline void MThostFtdcTradeField::set_orderlocalid(const char* value) {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  orderlocalid_->assign(value);
}
inline void MThostFtdcTradeField::set_orderlocalid(const char* value, size_t size) {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  orderlocalid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_orderlocalid() {
  set_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    orderlocalid_ = new ::std::string;
  }
  return orderlocalid_;
}
inline ::std::string* MThostFtdcTradeField::release_orderlocalid() {
  clear_has_orderlocalid();
  if (orderlocalid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderlocalid_;
    orderlocalid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ClearingPartID = 22;
inline bool MThostFtdcTradeField::has_clearingpartid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MThostFtdcTradeField::set_has_clearingpartid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MThostFtdcTradeField::clear_has_clearingpartid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MThostFtdcTradeField::clear_clearingpartid() {
  if (clearingpartid_ != &::google::protobuf::internal::kEmptyString) {
    clearingpartid_->clear();
  }
  clear_has_clearingpartid();
}
inline const ::std::string& MThostFtdcTradeField::clearingpartid() const {
  return *clearingpartid_;
}
inline void MThostFtdcTradeField::set_clearingpartid(const ::std::string& value) {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  clearingpartid_->assign(value);
}
inline void MThostFtdcTradeField::set_clearingpartid(const char* value) {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  clearingpartid_->assign(value);
}
inline void MThostFtdcTradeField::set_clearingpartid(const char* value, size_t size) {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  clearingpartid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_clearingpartid() {
  set_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    clearingpartid_ = new ::std::string;
  }
  return clearingpartid_;
}
inline ::std::string* MThostFtdcTradeField::release_clearingpartid() {
  clear_has_clearingpartid();
  if (clearingpartid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clearingpartid_;
    clearingpartid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SequenceNo = 23;
inline bool MThostFtdcTradeField::has_sequenceno() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MThostFtdcTradeField::set_has_sequenceno() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MThostFtdcTradeField::clear_has_sequenceno() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MThostFtdcTradeField::clear_sequenceno() {
  sequenceno_ = 0;
  clear_has_sequenceno();
}
inline ::google::protobuf::int32 MThostFtdcTradeField::sequenceno() const {
  return sequenceno_;
}
inline void MThostFtdcTradeField::set_sequenceno(::google::protobuf::int32 value) {
  set_has_sequenceno();
  sequenceno_ = value;
}

// required string TradingDay = 24;
inline bool MThostFtdcTradeField::has_tradingday() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MThostFtdcTradeField::set_has_tradingday() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MThostFtdcTradeField::clear_has_tradingday() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MThostFtdcTradeField::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& MThostFtdcTradeField::tradingday() const {
  return *tradingday_;
}
inline void MThostFtdcTradeField::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcTradeField::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcTradeField::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradeField::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* MThostFtdcTradeField::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SettlementID = 25;
inline bool MThostFtdcTradeField::has_settlementid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MThostFtdcTradeField::set_has_settlementid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MThostFtdcTradeField::clear_has_settlementid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MThostFtdcTradeField::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 MThostFtdcTradeField::settlementid() const {
  return settlementid_;
}
inline void MThostFtdcTradeField::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required int32 BrokerOrderSeq = 26;
inline bool MThostFtdcTradeField::has_brokerorderseq() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MThostFtdcTradeField::set_has_brokerorderseq() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MThostFtdcTradeField::clear_has_brokerorderseq() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MThostFtdcTradeField::clear_brokerorderseq() {
  brokerorderseq_ = 0;
  clear_has_brokerorderseq();
}
inline ::google::protobuf::int32 MThostFtdcTradeField::brokerorderseq() const {
  return brokerorderseq_;
}
inline void MThostFtdcTradeField::set_brokerorderseq(::google::protobuf::int32 value) {
  set_has_brokerorderseq();
  brokerorderseq_ = value;
}

// -------------------------------------------------------------------

// OrderAction

// required int32 HandleID = 1;
inline bool OrderAction::has_handleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderAction::set_has_handleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderAction::clear_has_handleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderAction::clear_handleid() {
  handleid_ = 0;
  clear_has_handleid();
}
inline ::google::protobuf::int32 OrderAction::handleid() const {
  return handleid_;
}
inline void OrderAction::set_handleid(::google::protobuf::int32 value) {
  set_has_handleid();
  handleid_ = value;
}

// required int32 Ref = 2;
inline bool OrderAction::has_ref() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderAction::set_has_ref() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderAction::clear_has_ref() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderAction::clear_ref() {
  ref_ = 0;
  clear_has_ref();
}
inline ::google::protobuf::int32 OrderAction::ref() const {
  return ref_;
}
inline void OrderAction::set_ref(::google::protobuf::int32 value) {
  set_has_ref();
  ref_ = value;
}

// optional string OrderSysID = 3;
inline bool OrderAction::has_ordersysid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderAction::set_has_ordersysid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderAction::clear_has_ordersysid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderAction::clear_ordersysid() {
  if (ordersysid_ != &::google::protobuf::internal::kEmptyString) {
    ordersysid_->clear();
  }
  clear_has_ordersysid();
}
inline const ::std::string& OrderAction::ordersysid() const {
  return *ordersysid_;
}
inline void OrderAction::set_ordersysid(const ::std::string& value) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(value);
}
inline void OrderAction::set_ordersysid(const char* value) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(value);
}
inline void OrderAction::set_ordersysid(const char* value, size_t size) {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  ordersysid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderAction::mutable_ordersysid() {
  set_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    ordersysid_ = new ::std::string;
  }
  return ordersysid_;
}
inline ::std::string* OrderAction::release_ordersysid() {
  clear_has_ordersysid();
  if (ordersysid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ordersysid_;
    ordersysid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 FrontID = 4;
inline bool OrderAction::has_frontid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderAction::set_has_frontid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderAction::clear_has_frontid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderAction::clear_frontid() {
  frontid_ = 0;
  clear_has_frontid();
}
inline ::google::protobuf::int32 OrderAction::frontid() const {
  return frontid_;
}
inline void OrderAction::set_frontid(::google::protobuf::int32 value) {
  set_has_frontid();
  frontid_ = value;
}

// optional int32 SessionID = 5;
inline bool OrderAction::has_sessionid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderAction::set_has_sessionid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderAction::clear_has_sessionid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderAction::clear_sessionid() {
  sessionid_ = 0;
  clear_has_sessionid();
}
inline ::google::protobuf::int32 OrderAction::sessionid() const {
  return sessionid_;
}
inline void OrderAction::set_sessionid(::google::protobuf::int32 value) {
  set_has_sessionid();
  sessionid_ = value;
}

// optional string ExchangeID = 6;
inline bool OrderAction::has_exchangeid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderAction::set_has_exchangeid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderAction::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderAction::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& OrderAction::exchangeid() const {
  return *exchangeid_;
}
inline void OrderAction::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void OrderAction::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void OrderAction::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderAction::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* OrderAction::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// MThostFtdcQryInvestorPositionField

// repeated string InstrumentID = 1;
inline int MThostFtdcQryInvestorPositionField::instrumentid_size() const {
  return instrumentid_.size();
}
inline void MThostFtdcQryInvestorPositionField::clear_instrumentid() {
  instrumentid_.Clear();
}
inline const ::std::string& MThostFtdcQryInvestorPositionField::instrumentid(int index) const {
  return instrumentid_.Get(index);
}
inline ::std::string* MThostFtdcQryInvestorPositionField::mutable_instrumentid(int index) {
  return instrumentid_.Mutable(index);
}
inline void MThostFtdcQryInvestorPositionField::set_instrumentid(int index, const ::std::string& value) {
  instrumentid_.Mutable(index)->assign(value);
}
inline void MThostFtdcQryInvestorPositionField::set_instrumentid(int index, const char* value) {
  instrumentid_.Mutable(index)->assign(value);
}
inline void MThostFtdcQryInvestorPositionField::set_instrumentid(int index, const char* value, size_t size) {
  instrumentid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcQryInvestorPositionField::add_instrumentid() {
  return instrumentid_.Add();
}
inline void MThostFtdcQryInvestorPositionField::add_instrumentid(const ::std::string& value) {
  instrumentid_.Add()->assign(value);
}
inline void MThostFtdcQryInvestorPositionField::add_instrumentid(const char* value) {
  instrumentid_.Add()->assign(value);
}
inline void MThostFtdcQryInvestorPositionField::add_instrumentid(const char* value, size_t size) {
  instrumentid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MThostFtdcQryInvestorPositionField::instrumentid() const {
  return instrumentid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MThostFtdcQryInvestorPositionField::mutable_instrumentid() {
  return &instrumentid_;
}

// -------------------------------------------------------------------

// RtnMThostFtdcQryInvestorPositionField

// repeated .FutureTradingPB.MThostFtdcInvestorPositionField InvestorPosition = 1;
inline int RtnMThostFtdcQryInvestorPositionField::investorposition_size() const {
  return investorposition_.size();
}
inline void RtnMThostFtdcQryInvestorPositionField::clear_investorposition() {
  investorposition_.Clear();
}
inline const ::FutureTradingPB::MThostFtdcInvestorPositionField& RtnMThostFtdcQryInvestorPositionField::investorposition(int index) const {
  return investorposition_.Get(index);
}
inline ::FutureTradingPB::MThostFtdcInvestorPositionField* RtnMThostFtdcQryInvestorPositionField::mutable_investorposition(int index) {
  return investorposition_.Mutable(index);
}
inline ::FutureTradingPB::MThostFtdcInvestorPositionField* RtnMThostFtdcQryInvestorPositionField::add_investorposition() {
  return investorposition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInvestorPositionField >&
RtnMThostFtdcQryInvestorPositionField::investorposition() const {
  return investorposition_;
}
inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInvestorPositionField >*
RtnMThostFtdcQryInvestorPositionField::mutable_investorposition() {
  return &investorposition_;
}

// -------------------------------------------------------------------

// MThostFtdcInvestorPositionField

// required string InstrumentID = 1;
inline bool MThostFtdcInvestorPositionField::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MThostFtdcInvestorPositionField::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MThostFtdcInvestorPositionField::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& MThostFtdcInvestorPositionField::instrumentid() const {
  return *instrumentid_;
}
inline void MThostFtdcInvestorPositionField::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInvestorPositionField::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* MThostFtdcInvestorPositionField::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PosiDirection = 2;
inline bool MThostFtdcInvestorPositionField::has_posidirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_posidirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MThostFtdcInvestorPositionField::clear_has_posidirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MThostFtdcInvestorPositionField::clear_posidirection() {
  if (posidirection_ != &::google::protobuf::internal::kEmptyString) {
    posidirection_->clear();
  }
  clear_has_posidirection();
}
inline const ::std::string& MThostFtdcInvestorPositionField::posidirection() const {
  return *posidirection_;
}
inline void MThostFtdcInvestorPositionField::set_posidirection(const ::std::string& value) {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  posidirection_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_posidirection(const char* value) {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  posidirection_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_posidirection(const char* value, size_t size) {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  posidirection_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInvestorPositionField::mutable_posidirection() {
  set_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    posidirection_ = new ::std::string;
  }
  return posidirection_;
}
inline ::std::string* MThostFtdcInvestorPositionField::release_posidirection() {
  clear_has_posidirection();
  if (posidirection_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = posidirection_;
    posidirection_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string HedgeFlag = 3;
inline bool MThostFtdcInvestorPositionField::has_hedgeflag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_hedgeflag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MThostFtdcInvestorPositionField::clear_has_hedgeflag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MThostFtdcInvestorPositionField::clear_hedgeflag() {
  if (hedgeflag_ != &::google::protobuf::internal::kEmptyString) {
    hedgeflag_->clear();
  }
  clear_has_hedgeflag();
}
inline const ::std::string& MThostFtdcInvestorPositionField::hedgeflag() const {
  return *hedgeflag_;
}
inline void MThostFtdcInvestorPositionField::set_hedgeflag(const ::std::string& value) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_hedgeflag(const char* value) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_hedgeflag(const char* value, size_t size) {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  hedgeflag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInvestorPositionField::mutable_hedgeflag() {
  set_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    hedgeflag_ = new ::std::string;
  }
  return hedgeflag_;
}
inline ::std::string* MThostFtdcInvestorPositionField::release_hedgeflag() {
  clear_has_hedgeflag();
  if (hedgeflag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hedgeflag_;
    hedgeflag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PositionDate = 4;
inline bool MThostFtdcInvestorPositionField::has_positiondate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_positiondate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MThostFtdcInvestorPositionField::clear_has_positiondate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MThostFtdcInvestorPositionField::clear_positiondate() {
  if (positiondate_ != &::google::protobuf::internal::kEmptyString) {
    positiondate_->clear();
  }
  clear_has_positiondate();
}
inline const ::std::string& MThostFtdcInvestorPositionField::positiondate() const {
  return *positiondate_;
}
inline void MThostFtdcInvestorPositionField::set_positiondate(const ::std::string& value) {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  positiondate_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_positiondate(const char* value) {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  positiondate_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_positiondate(const char* value, size_t size) {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  positiondate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInvestorPositionField::mutable_positiondate() {
  set_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    positiondate_ = new ::std::string;
  }
  return positiondate_;
}
inline ::std::string* MThostFtdcInvestorPositionField::release_positiondate() {
  clear_has_positiondate();
  if (positiondate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positiondate_;
    positiondate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 YdPosition = 5;
inline bool MThostFtdcInvestorPositionField::has_ydposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_ydposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MThostFtdcInvestorPositionField::clear_has_ydposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MThostFtdcInvestorPositionField::clear_ydposition() {
  ydposition_ = 0;
  clear_has_ydposition();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::ydposition() const {
  return ydposition_;
}
inline void MThostFtdcInvestorPositionField::set_ydposition(::google::protobuf::int32 value) {
  set_has_ydposition();
  ydposition_ = value;
}

// required int32 Position = 6;
inline bool MThostFtdcInvestorPositionField::has_position() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_position() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MThostFtdcInvestorPositionField::clear_has_position() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MThostFtdcInvestorPositionField::clear_position() {
  position_ = 0;
  clear_has_position();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::position() const {
  return position_;
}
inline void MThostFtdcInvestorPositionField::set_position(::google::protobuf::int32 value) {
  set_has_position();
  position_ = value;
}

// required int32 LongFrozen = 7;
inline bool MThostFtdcInvestorPositionField::has_longfrozen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_longfrozen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MThostFtdcInvestorPositionField::clear_has_longfrozen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MThostFtdcInvestorPositionField::clear_longfrozen() {
  longfrozen_ = 0;
  clear_has_longfrozen();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::longfrozen() const {
  return longfrozen_;
}
inline void MThostFtdcInvestorPositionField::set_longfrozen(::google::protobuf::int32 value) {
  set_has_longfrozen();
  longfrozen_ = value;
}

// required int32 ShortFrozen = 8;
inline bool MThostFtdcInvestorPositionField::has_shortfrozen() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_shortfrozen() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MThostFtdcInvestorPositionField::clear_has_shortfrozen() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MThostFtdcInvestorPositionField::clear_shortfrozen() {
  shortfrozen_ = 0;
  clear_has_shortfrozen();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::shortfrozen() const {
  return shortfrozen_;
}
inline void MThostFtdcInvestorPositionField::set_shortfrozen(::google::protobuf::int32 value) {
  set_has_shortfrozen();
  shortfrozen_ = value;
}

// required double LongFrozenAmount = 9;
inline bool MThostFtdcInvestorPositionField::has_longfrozenamount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_longfrozenamount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MThostFtdcInvestorPositionField::clear_has_longfrozenamount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MThostFtdcInvestorPositionField::clear_longfrozenamount() {
  longfrozenamount_ = 0;
  clear_has_longfrozenamount();
}
inline double MThostFtdcInvestorPositionField::longfrozenamount() const {
  return longfrozenamount_;
}
inline void MThostFtdcInvestorPositionField::set_longfrozenamount(double value) {
  set_has_longfrozenamount();
  longfrozenamount_ = value;
}

// required double ShortFrozenAmount = 10;
inline bool MThostFtdcInvestorPositionField::has_shortfrozenamount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_shortfrozenamount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MThostFtdcInvestorPositionField::clear_has_shortfrozenamount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MThostFtdcInvestorPositionField::clear_shortfrozenamount() {
  shortfrozenamount_ = 0;
  clear_has_shortfrozenamount();
}
inline double MThostFtdcInvestorPositionField::shortfrozenamount() const {
  return shortfrozenamount_;
}
inline void MThostFtdcInvestorPositionField::set_shortfrozenamount(double value) {
  set_has_shortfrozenamount();
  shortfrozenamount_ = value;
}

// required int32 OpenVolume = 11;
inline bool MThostFtdcInvestorPositionField::has_openvolume() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_openvolume() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MThostFtdcInvestorPositionField::clear_has_openvolume() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MThostFtdcInvestorPositionField::clear_openvolume() {
  openvolume_ = 0;
  clear_has_openvolume();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::openvolume() const {
  return openvolume_;
}
inline void MThostFtdcInvestorPositionField::set_openvolume(::google::protobuf::int32 value) {
  set_has_openvolume();
  openvolume_ = value;
}

// required int32 CloseVolume = 12;
inline bool MThostFtdcInvestorPositionField::has_closevolume() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_closevolume() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MThostFtdcInvestorPositionField::clear_has_closevolume() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MThostFtdcInvestorPositionField::clear_closevolume() {
  closevolume_ = 0;
  clear_has_closevolume();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::closevolume() const {
  return closevolume_;
}
inline void MThostFtdcInvestorPositionField::set_closevolume(::google::protobuf::int32 value) {
  set_has_closevolume();
  closevolume_ = value;
}

// required double OpenAmount = 13;
inline bool MThostFtdcInvestorPositionField::has_openamount() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_openamount() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_openamount() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MThostFtdcInvestorPositionField::clear_openamount() {
  openamount_ = 0;
  clear_has_openamount();
}
inline double MThostFtdcInvestorPositionField::openamount() const {
  return openamount_;
}
inline void MThostFtdcInvestorPositionField::set_openamount(double value) {
  set_has_openamount();
  openamount_ = value;
}

// required double CloseAmount = 14;
inline bool MThostFtdcInvestorPositionField::has_closeamount() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_closeamount() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_closeamount() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MThostFtdcInvestorPositionField::clear_closeamount() {
  closeamount_ = 0;
  clear_has_closeamount();
}
inline double MThostFtdcInvestorPositionField::closeamount() const {
  return closeamount_;
}
inline void MThostFtdcInvestorPositionField::set_closeamount(double value) {
  set_has_closeamount();
  closeamount_ = value;
}

// required double PositionCost = 15;
inline bool MThostFtdcInvestorPositionField::has_positioncost() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_positioncost() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_positioncost() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MThostFtdcInvestorPositionField::clear_positioncost() {
  positioncost_ = 0;
  clear_has_positioncost();
}
inline double MThostFtdcInvestorPositionField::positioncost() const {
  return positioncost_;
}
inline void MThostFtdcInvestorPositionField::set_positioncost(double value) {
  set_has_positioncost();
  positioncost_ = value;
}

// required double PreMargin = 16;
inline bool MThostFtdcInvestorPositionField::has_premargin() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_premargin() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_premargin() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MThostFtdcInvestorPositionField::clear_premargin() {
  premargin_ = 0;
  clear_has_premargin();
}
inline double MThostFtdcInvestorPositionField::premargin() const {
  return premargin_;
}
inline void MThostFtdcInvestorPositionField::set_premargin(double value) {
  set_has_premargin();
  premargin_ = value;
}

// required double UseMargin = 17;
inline bool MThostFtdcInvestorPositionField::has_usemargin() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_usemargin() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_usemargin() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MThostFtdcInvestorPositionField::clear_usemargin() {
  usemargin_ = 0;
  clear_has_usemargin();
}
inline double MThostFtdcInvestorPositionField::usemargin() const {
  return usemargin_;
}
inline void MThostFtdcInvestorPositionField::set_usemargin(double value) {
  set_has_usemargin();
  usemargin_ = value;
}

// required double FrozenMargin = 18;
inline bool MThostFtdcInvestorPositionField::has_frozenmargin() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_frozenmargin() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_frozenmargin() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MThostFtdcInvestorPositionField::clear_frozenmargin() {
  frozenmargin_ = 0;
  clear_has_frozenmargin();
}
inline double MThostFtdcInvestorPositionField::frozenmargin() const {
  return frozenmargin_;
}
inline void MThostFtdcInvestorPositionField::set_frozenmargin(double value) {
  set_has_frozenmargin();
  frozenmargin_ = value;
}

// required double FrozenCash = 19;
inline bool MThostFtdcInvestorPositionField::has_frozencash() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_frozencash() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_frozencash() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MThostFtdcInvestorPositionField::clear_frozencash() {
  frozencash_ = 0;
  clear_has_frozencash();
}
inline double MThostFtdcInvestorPositionField::frozencash() const {
  return frozencash_;
}
inline void MThostFtdcInvestorPositionField::set_frozencash(double value) {
  set_has_frozencash();
  frozencash_ = value;
}

// required double FrozenCommission = 20;
inline bool MThostFtdcInvestorPositionField::has_frozencommission() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_frozencommission() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_frozencommission() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MThostFtdcInvestorPositionField::clear_frozencommission() {
  frozencommission_ = 0;
  clear_has_frozencommission();
}
inline double MThostFtdcInvestorPositionField::frozencommission() const {
  return frozencommission_;
}
inline void MThostFtdcInvestorPositionField::set_frozencommission(double value) {
  set_has_frozencommission();
  frozencommission_ = value;
}

// required double CashIn = 21;
inline bool MThostFtdcInvestorPositionField::has_cashin() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_cashin() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_cashin() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MThostFtdcInvestorPositionField::clear_cashin() {
  cashin_ = 0;
  clear_has_cashin();
}
inline double MThostFtdcInvestorPositionField::cashin() const {
  return cashin_;
}
inline void MThostFtdcInvestorPositionField::set_cashin(double value) {
  set_has_cashin();
  cashin_ = value;
}

// required double Commission = 22;
inline bool MThostFtdcInvestorPositionField::has_commission() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_commission() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_commission() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MThostFtdcInvestorPositionField::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double MThostFtdcInvestorPositionField::commission() const {
  return commission_;
}
inline void MThostFtdcInvestorPositionField::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double CloseProfit = 23;
inline bool MThostFtdcInvestorPositionField::has_closeprofit() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_closeprofit() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_closeprofit() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MThostFtdcInvestorPositionField::clear_closeprofit() {
  closeprofit_ = 0;
  clear_has_closeprofit();
}
inline double MThostFtdcInvestorPositionField::closeprofit() const {
  return closeprofit_;
}
inline void MThostFtdcInvestorPositionField::set_closeprofit(double value) {
  set_has_closeprofit();
  closeprofit_ = value;
}

// required double PositionProfit = 24;
inline bool MThostFtdcInvestorPositionField::has_positionprofit() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_positionprofit() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_positionprofit() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MThostFtdcInvestorPositionField::clear_positionprofit() {
  positionprofit_ = 0;
  clear_has_positionprofit();
}
inline double MThostFtdcInvestorPositionField::positionprofit() const {
  return positionprofit_;
}
inline void MThostFtdcInvestorPositionField::set_positionprofit(double value) {
  set_has_positionprofit();
  positionprofit_ = value;
}

// required double PreSettlementPrice = 25;
inline bool MThostFtdcInvestorPositionField::has_presettlementprice() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_presettlementprice() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_presettlementprice() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MThostFtdcInvestorPositionField::clear_presettlementprice() {
  presettlementprice_ = 0;
  clear_has_presettlementprice();
}
inline double MThostFtdcInvestorPositionField::presettlementprice() const {
  return presettlementprice_;
}
inline void MThostFtdcInvestorPositionField::set_presettlementprice(double value) {
  set_has_presettlementprice();
  presettlementprice_ = value;
}

// required double SettlementPrice = 26;
inline bool MThostFtdcInvestorPositionField::has_settlementprice() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_settlementprice() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_settlementprice() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MThostFtdcInvestorPositionField::clear_settlementprice() {
  settlementprice_ = 0;
  clear_has_settlementprice();
}
inline double MThostFtdcInvestorPositionField::settlementprice() const {
  return settlementprice_;
}
inline void MThostFtdcInvestorPositionField::set_settlementprice(double value) {
  set_has_settlementprice();
  settlementprice_ = value;
}

// required string TradingDay = 27;
inline bool MThostFtdcInvestorPositionField::has_tradingday() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_tradingday() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_tradingday() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MThostFtdcInvestorPositionField::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& MThostFtdcInvestorPositionField::tradingday() const {
  return *tradingday_;
}
inline void MThostFtdcInvestorPositionField::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcInvestorPositionField::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInvestorPositionField::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* MThostFtdcInvestorPositionField::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SettlementID = 28;
inline bool MThostFtdcInvestorPositionField::has_settlementid() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_settlementid() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_settlementid() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MThostFtdcInvestorPositionField::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 MThostFtdcInvestorPositionField::settlementid() const {
  return settlementid_;
}
inline void MThostFtdcInvestorPositionField::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required double OpenCost = 29;
inline bool MThostFtdcInvestorPositionField::has_opencost() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_opencost() {
  _has_bits_[0] |= 0x10000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_opencost() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void MThostFtdcInvestorPositionField::clear_opencost() {
  opencost_ = 0;
  clear_has_opencost();
}
inline double MThostFtdcInvestorPositionField::opencost() const {
  return opencost_;
}
inline void MThostFtdcInvestorPositionField::set_opencost(double value) {
  set_has_opencost();
  opencost_ = value;
}

// required double ExchangeMargin = 30;
inline bool MThostFtdcInvestorPositionField::has_exchangemargin() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_exchangemargin() {
  _has_bits_[0] |= 0x20000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_exchangemargin() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void MThostFtdcInvestorPositionField::clear_exchangemargin() {
  exchangemargin_ = 0;
  clear_has_exchangemargin();
}
inline double MThostFtdcInvestorPositionField::exchangemargin() const {
  return exchangemargin_;
}
inline void MThostFtdcInvestorPositionField::set_exchangemargin(double value) {
  set_has_exchangemargin();
  exchangemargin_ = value;
}

// required double CombPosition = 31;
inline bool MThostFtdcInvestorPositionField::has_combposition() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_combposition() {
  _has_bits_[0] |= 0x40000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_combposition() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void MThostFtdcInvestorPositionField::clear_combposition() {
  combposition_ = 0;
  clear_has_combposition();
}
inline double MThostFtdcInvestorPositionField::combposition() const {
  return combposition_;
}
inline void MThostFtdcInvestorPositionField::set_combposition(double value) {
  set_has_combposition();
  combposition_ = value;
}

// required double CombLongFrozen = 32;
inline bool MThostFtdcInvestorPositionField::has_comblongfrozen() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_comblongfrozen() {
  _has_bits_[0] |= 0x80000000u;
}
inline void MThostFtdcInvestorPositionField::clear_has_comblongfrozen() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void MThostFtdcInvestorPositionField::clear_comblongfrozen() {
  comblongfrozen_ = 0;
  clear_has_comblongfrozen();
}
inline double MThostFtdcInvestorPositionField::comblongfrozen() const {
  return comblongfrozen_;
}
inline void MThostFtdcInvestorPositionField::set_comblongfrozen(double value) {
  set_has_comblongfrozen();
  comblongfrozen_ = value;
}

// required double CombShortFrozen = 33;
inline bool MThostFtdcInvestorPositionField::has_combshortfrozen() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_combshortfrozen() {
  _has_bits_[1] |= 0x00000001u;
}
inline void MThostFtdcInvestorPositionField::clear_has_combshortfrozen() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void MThostFtdcInvestorPositionField::clear_combshortfrozen() {
  combshortfrozen_ = 0;
  clear_has_combshortfrozen();
}
inline double MThostFtdcInvestorPositionField::combshortfrozen() const {
  return combshortfrozen_;
}
inline void MThostFtdcInvestorPositionField::set_combshortfrozen(double value) {
  set_has_combshortfrozen();
  combshortfrozen_ = value;
}

// required double CloseProfitByDate = 34;
inline bool MThostFtdcInvestorPositionField::has_closeprofitbydate() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_closeprofitbydate() {
  _has_bits_[1] |= 0x00000002u;
}
inline void MThostFtdcInvestorPositionField::clear_has_closeprofitbydate() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void MThostFtdcInvestorPositionField::clear_closeprofitbydate() {
  closeprofitbydate_ = 0;
  clear_has_closeprofitbydate();
}
inline double MThostFtdcInvestorPositionField::closeprofitbydate() const {
  return closeprofitbydate_;
}
inline void MThostFtdcInvestorPositionField::set_closeprofitbydate(double value) {
  set_has_closeprofitbydate();
  closeprofitbydate_ = value;
}

// required double CloseProfitByTrade = 35;
inline bool MThostFtdcInvestorPositionField::has_closeprofitbytrade() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_closeprofitbytrade() {
  _has_bits_[1] |= 0x00000004u;
}
inline void MThostFtdcInvestorPositionField::clear_has_closeprofitbytrade() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void MThostFtdcInvestorPositionField::clear_closeprofitbytrade() {
  closeprofitbytrade_ = 0;
  clear_has_closeprofitbytrade();
}
inline double MThostFtdcInvestorPositionField::closeprofitbytrade() const {
  return closeprofitbytrade_;
}
inline void MThostFtdcInvestorPositionField::set_closeprofitbytrade(double value) {
  set_has_closeprofitbytrade();
  closeprofitbytrade_ = value;
}

// required double TodayPosition = 36;
inline bool MThostFtdcInvestorPositionField::has_todayposition() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_todayposition() {
  _has_bits_[1] |= 0x00000008u;
}
inline void MThostFtdcInvestorPositionField::clear_has_todayposition() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void MThostFtdcInvestorPositionField::clear_todayposition() {
  todayposition_ = 0;
  clear_has_todayposition();
}
inline double MThostFtdcInvestorPositionField::todayposition() const {
  return todayposition_;
}
inline void MThostFtdcInvestorPositionField::set_todayposition(double value) {
  set_has_todayposition();
  todayposition_ = value;
}

// required double MarginRateByMoney = 37;
inline bool MThostFtdcInvestorPositionField::has_marginratebymoney() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_marginratebymoney() {
  _has_bits_[1] |= 0x00000010u;
}
inline void MThostFtdcInvestorPositionField::clear_has_marginratebymoney() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void MThostFtdcInvestorPositionField::clear_marginratebymoney() {
  marginratebymoney_ = 0;
  clear_has_marginratebymoney();
}
inline double MThostFtdcInvestorPositionField::marginratebymoney() const {
  return marginratebymoney_;
}
inline void MThostFtdcInvestorPositionField::set_marginratebymoney(double value) {
  set_has_marginratebymoney();
  marginratebymoney_ = value;
}

// required double MarginRateByVolume = 38;
inline bool MThostFtdcInvestorPositionField::has_marginratebyvolume() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void MThostFtdcInvestorPositionField::set_has_marginratebyvolume() {
  _has_bits_[1] |= 0x00000020u;
}
inline void MThostFtdcInvestorPositionField::clear_has_marginratebyvolume() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void MThostFtdcInvestorPositionField::clear_marginratebyvolume() {
  marginratebyvolume_ = 0;
  clear_has_marginratebyvolume();
}
inline double MThostFtdcInvestorPositionField::marginratebyvolume() const {
  return marginratebyvolume_;
}
inline void MThostFtdcInvestorPositionField::set_marginratebyvolume(double value) {
  set_has_marginratebyvolume();
  marginratebyvolume_ = value;
}

// -------------------------------------------------------------------

// MThostFtdcTradingAccountField

// required string BrokerID = 1;
inline bool MThostFtdcTradingAccountField::has_brokerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_brokerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MThostFtdcTradingAccountField::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MThostFtdcTradingAccountField::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& MThostFtdcTradingAccountField::brokerid() const {
  return *brokerid_;
}
inline void MThostFtdcTradingAccountField::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void MThostFtdcTradingAccountField::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void MThostFtdcTradingAccountField::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradingAccountField::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* MThostFtdcTradingAccountField::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string AccountID = 2;
inline bool MThostFtdcTradingAccountField::has_accountid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_accountid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MThostFtdcTradingAccountField::clear_has_accountid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MThostFtdcTradingAccountField::clear_accountid() {
  if (accountid_ != &::google::protobuf::internal::kEmptyString) {
    accountid_->clear();
  }
  clear_has_accountid();
}
inline const ::std::string& MThostFtdcTradingAccountField::accountid() const {
  return *accountid_;
}
inline void MThostFtdcTradingAccountField::set_accountid(const ::std::string& value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void MThostFtdcTradingAccountField::set_accountid(const char* value) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(value);
}
inline void MThostFtdcTradingAccountField::set_accountid(const char* value, size_t size) {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  accountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradingAccountField::mutable_accountid() {
  set_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    accountid_ = new ::std::string;
  }
  return accountid_;
}
inline ::std::string* MThostFtdcTradingAccountField::release_accountid() {
  clear_has_accountid();
  if (accountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountid_;
    accountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double PreMortgage = 3;
inline bool MThostFtdcTradingAccountField::has_premortgage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_premortgage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MThostFtdcTradingAccountField::clear_has_premortgage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MThostFtdcTradingAccountField::clear_premortgage() {
  premortgage_ = 0;
  clear_has_premortgage();
}
inline double MThostFtdcTradingAccountField::premortgage() const {
  return premortgage_;
}
inline void MThostFtdcTradingAccountField::set_premortgage(double value) {
  set_has_premortgage();
  premortgage_ = value;
}

// required double PreCredit = 4;
inline bool MThostFtdcTradingAccountField::has_precredit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_precredit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MThostFtdcTradingAccountField::clear_has_precredit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MThostFtdcTradingAccountField::clear_precredit() {
  precredit_ = 0;
  clear_has_precredit();
}
inline double MThostFtdcTradingAccountField::precredit() const {
  return precredit_;
}
inline void MThostFtdcTradingAccountField::set_precredit(double value) {
  set_has_precredit();
  precredit_ = value;
}

// required double PreDeposit = 5;
inline bool MThostFtdcTradingAccountField::has_predeposit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_predeposit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MThostFtdcTradingAccountField::clear_has_predeposit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MThostFtdcTradingAccountField::clear_predeposit() {
  predeposit_ = 0;
  clear_has_predeposit();
}
inline double MThostFtdcTradingAccountField::predeposit() const {
  return predeposit_;
}
inline void MThostFtdcTradingAccountField::set_predeposit(double value) {
  set_has_predeposit();
  predeposit_ = value;
}

// required double PreBalance = 6;
inline bool MThostFtdcTradingAccountField::has_prebalance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_prebalance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MThostFtdcTradingAccountField::clear_has_prebalance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MThostFtdcTradingAccountField::clear_prebalance() {
  prebalance_ = 0;
  clear_has_prebalance();
}
inline double MThostFtdcTradingAccountField::prebalance() const {
  return prebalance_;
}
inline void MThostFtdcTradingAccountField::set_prebalance(double value) {
  set_has_prebalance();
  prebalance_ = value;
}

// required double PreMargin = 7;
inline bool MThostFtdcTradingAccountField::has_premargin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_premargin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MThostFtdcTradingAccountField::clear_has_premargin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MThostFtdcTradingAccountField::clear_premargin() {
  premargin_ = 0;
  clear_has_premargin();
}
inline double MThostFtdcTradingAccountField::premargin() const {
  return premargin_;
}
inline void MThostFtdcTradingAccountField::set_premargin(double value) {
  set_has_premargin();
  premargin_ = value;
}

// required double InterestBase = 8;
inline bool MThostFtdcTradingAccountField::has_interestbase() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_interestbase() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MThostFtdcTradingAccountField::clear_has_interestbase() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MThostFtdcTradingAccountField::clear_interestbase() {
  interestbase_ = 0;
  clear_has_interestbase();
}
inline double MThostFtdcTradingAccountField::interestbase() const {
  return interestbase_;
}
inline void MThostFtdcTradingAccountField::set_interestbase(double value) {
  set_has_interestbase();
  interestbase_ = value;
}

// required double Interest = 9;
inline bool MThostFtdcTradingAccountField::has_interest() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_interest() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MThostFtdcTradingAccountField::clear_has_interest() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MThostFtdcTradingAccountField::clear_interest() {
  interest_ = 0;
  clear_has_interest();
}
inline double MThostFtdcTradingAccountField::interest() const {
  return interest_;
}
inline void MThostFtdcTradingAccountField::set_interest(double value) {
  set_has_interest();
  interest_ = value;
}

// required double Deposit = 10;
inline bool MThostFtdcTradingAccountField::has_deposit() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_deposit() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MThostFtdcTradingAccountField::clear_has_deposit() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MThostFtdcTradingAccountField::clear_deposit() {
  deposit_ = 0;
  clear_has_deposit();
}
inline double MThostFtdcTradingAccountField::deposit() const {
  return deposit_;
}
inline void MThostFtdcTradingAccountField::set_deposit(double value) {
  set_has_deposit();
  deposit_ = value;
}

// required double Withdraw = 11;
inline bool MThostFtdcTradingAccountField::has_withdraw() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_withdraw() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MThostFtdcTradingAccountField::clear_has_withdraw() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MThostFtdcTradingAccountField::clear_withdraw() {
  withdraw_ = 0;
  clear_has_withdraw();
}
inline double MThostFtdcTradingAccountField::withdraw() const {
  return withdraw_;
}
inline void MThostFtdcTradingAccountField::set_withdraw(double value) {
  set_has_withdraw();
  withdraw_ = value;
}

// required double FrozenMargin = 12;
inline bool MThostFtdcTradingAccountField::has_frozenmargin() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_frozenmargin() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MThostFtdcTradingAccountField::clear_has_frozenmargin() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MThostFtdcTradingAccountField::clear_frozenmargin() {
  frozenmargin_ = 0;
  clear_has_frozenmargin();
}
inline double MThostFtdcTradingAccountField::frozenmargin() const {
  return frozenmargin_;
}
inline void MThostFtdcTradingAccountField::set_frozenmargin(double value) {
  set_has_frozenmargin();
  frozenmargin_ = value;
}

// required double FrozenCash = 13;
inline bool MThostFtdcTradingAccountField::has_frozencash() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_frozencash() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MThostFtdcTradingAccountField::clear_has_frozencash() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MThostFtdcTradingAccountField::clear_frozencash() {
  frozencash_ = 0;
  clear_has_frozencash();
}
inline double MThostFtdcTradingAccountField::frozencash() const {
  return frozencash_;
}
inline void MThostFtdcTradingAccountField::set_frozencash(double value) {
  set_has_frozencash();
  frozencash_ = value;
}

// required double FrozenCommission = 14;
inline bool MThostFtdcTradingAccountField::has_frozencommission() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_frozencommission() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MThostFtdcTradingAccountField::clear_has_frozencommission() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MThostFtdcTradingAccountField::clear_frozencommission() {
  frozencommission_ = 0;
  clear_has_frozencommission();
}
inline double MThostFtdcTradingAccountField::frozencommission() const {
  return frozencommission_;
}
inline void MThostFtdcTradingAccountField::set_frozencommission(double value) {
  set_has_frozencommission();
  frozencommission_ = value;
}

// required double CurrMargin = 15;
inline bool MThostFtdcTradingAccountField::has_currmargin() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_currmargin() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MThostFtdcTradingAccountField::clear_has_currmargin() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MThostFtdcTradingAccountField::clear_currmargin() {
  currmargin_ = 0;
  clear_has_currmargin();
}
inline double MThostFtdcTradingAccountField::currmargin() const {
  return currmargin_;
}
inline void MThostFtdcTradingAccountField::set_currmargin(double value) {
  set_has_currmargin();
  currmargin_ = value;
}

// required double CashIn = 16;
inline bool MThostFtdcTradingAccountField::has_cashin() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_cashin() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MThostFtdcTradingAccountField::clear_has_cashin() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MThostFtdcTradingAccountField::clear_cashin() {
  cashin_ = 0;
  clear_has_cashin();
}
inline double MThostFtdcTradingAccountField::cashin() const {
  return cashin_;
}
inline void MThostFtdcTradingAccountField::set_cashin(double value) {
  set_has_cashin();
  cashin_ = value;
}

// required double Commission = 17;
inline bool MThostFtdcTradingAccountField::has_commission() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_commission() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MThostFtdcTradingAccountField::clear_has_commission() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MThostFtdcTradingAccountField::clear_commission() {
  commission_ = 0;
  clear_has_commission();
}
inline double MThostFtdcTradingAccountField::commission() const {
  return commission_;
}
inline void MThostFtdcTradingAccountField::set_commission(double value) {
  set_has_commission();
  commission_ = value;
}

// required double CloseProfit = 18;
inline bool MThostFtdcTradingAccountField::has_closeprofit() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_closeprofit() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MThostFtdcTradingAccountField::clear_has_closeprofit() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MThostFtdcTradingAccountField::clear_closeprofit() {
  closeprofit_ = 0;
  clear_has_closeprofit();
}
inline double MThostFtdcTradingAccountField::closeprofit() const {
  return closeprofit_;
}
inline void MThostFtdcTradingAccountField::set_closeprofit(double value) {
  set_has_closeprofit();
  closeprofit_ = value;
}

// required double PositionProfit = 19;
inline bool MThostFtdcTradingAccountField::has_positionprofit() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_positionprofit() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MThostFtdcTradingAccountField::clear_has_positionprofit() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MThostFtdcTradingAccountField::clear_positionprofit() {
  positionprofit_ = 0;
  clear_has_positionprofit();
}
inline double MThostFtdcTradingAccountField::positionprofit() const {
  return positionprofit_;
}
inline void MThostFtdcTradingAccountField::set_positionprofit(double value) {
  set_has_positionprofit();
  positionprofit_ = value;
}

// required double Balance = 20;
inline bool MThostFtdcTradingAccountField::has_balance() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_balance() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MThostFtdcTradingAccountField::clear_has_balance() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MThostFtdcTradingAccountField::clear_balance() {
  balance_ = 0;
  clear_has_balance();
}
inline double MThostFtdcTradingAccountField::balance() const {
  return balance_;
}
inline void MThostFtdcTradingAccountField::set_balance(double value) {
  set_has_balance();
  balance_ = value;
}

// required double Available = 21;
inline bool MThostFtdcTradingAccountField::has_available() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_available() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MThostFtdcTradingAccountField::clear_has_available() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MThostFtdcTradingAccountField::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline double MThostFtdcTradingAccountField::available() const {
  return available_;
}
inline void MThostFtdcTradingAccountField::set_available(double value) {
  set_has_available();
  available_ = value;
}

// required double WithdrawQuota = 22;
inline bool MThostFtdcTradingAccountField::has_withdrawquota() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_withdrawquota() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MThostFtdcTradingAccountField::clear_has_withdrawquota() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MThostFtdcTradingAccountField::clear_withdrawquota() {
  withdrawquota_ = 0;
  clear_has_withdrawquota();
}
inline double MThostFtdcTradingAccountField::withdrawquota() const {
  return withdrawquota_;
}
inline void MThostFtdcTradingAccountField::set_withdrawquota(double value) {
  set_has_withdrawquota();
  withdrawquota_ = value;
}

// required double Reserve = 23;
inline bool MThostFtdcTradingAccountField::has_reserve() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_reserve() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MThostFtdcTradingAccountField::clear_has_reserve() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MThostFtdcTradingAccountField::clear_reserve() {
  reserve_ = 0;
  clear_has_reserve();
}
inline double MThostFtdcTradingAccountField::reserve() const {
  return reserve_;
}
inline void MThostFtdcTradingAccountField::set_reserve(double value) {
  set_has_reserve();
  reserve_ = value;
}

// required string TradingDay = 24;
inline bool MThostFtdcTradingAccountField::has_tradingday() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_tradingday() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MThostFtdcTradingAccountField::clear_has_tradingday() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MThostFtdcTradingAccountField::clear_tradingday() {
  if (tradingday_ != &::google::protobuf::internal::kEmptyString) {
    tradingday_->clear();
  }
  clear_has_tradingday();
}
inline const ::std::string& MThostFtdcTradingAccountField::tradingday() const {
  return *tradingday_;
}
inline void MThostFtdcTradingAccountField::set_tradingday(const ::std::string& value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcTradingAccountField::set_tradingday(const char* value) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(value);
}
inline void MThostFtdcTradingAccountField::set_tradingday(const char* value, size_t size) {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  tradingday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcTradingAccountField::mutable_tradingday() {
  set_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    tradingday_ = new ::std::string;
  }
  return tradingday_;
}
inline ::std::string* MThostFtdcTradingAccountField::release_tradingday() {
  clear_has_tradingday();
  if (tradingday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tradingday_;
    tradingday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 SettlementID = 25;
inline bool MThostFtdcTradingAccountField::has_settlementid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_settlementid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MThostFtdcTradingAccountField::clear_has_settlementid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MThostFtdcTradingAccountField::clear_settlementid() {
  settlementid_ = 0;
  clear_has_settlementid();
}
inline ::google::protobuf::int32 MThostFtdcTradingAccountField::settlementid() const {
  return settlementid_;
}
inline void MThostFtdcTradingAccountField::set_settlementid(::google::protobuf::int32 value) {
  set_has_settlementid();
  settlementid_ = value;
}

// required double Credit = 26;
inline bool MThostFtdcTradingAccountField::has_credit() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_credit() {
  _has_bits_[0] |= 0x02000000u;
}
inline void MThostFtdcTradingAccountField::clear_has_credit() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void MThostFtdcTradingAccountField::clear_credit() {
  credit_ = 0;
  clear_has_credit();
}
inline double MThostFtdcTradingAccountField::credit() const {
  return credit_;
}
inline void MThostFtdcTradingAccountField::set_credit(double value) {
  set_has_credit();
  credit_ = value;
}

// required double Mortgage = 27;
inline bool MThostFtdcTradingAccountField::has_mortgage() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_mortgage() {
  _has_bits_[0] |= 0x04000000u;
}
inline void MThostFtdcTradingAccountField::clear_has_mortgage() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void MThostFtdcTradingAccountField::clear_mortgage() {
  mortgage_ = 0;
  clear_has_mortgage();
}
inline double MThostFtdcTradingAccountField::mortgage() const {
  return mortgage_;
}
inline void MThostFtdcTradingAccountField::set_mortgage(double value) {
  set_has_mortgage();
  mortgage_ = value;
}

// required double ExchangeMargin = 28;
inline bool MThostFtdcTradingAccountField::has_exchangemargin() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void MThostFtdcTradingAccountField::set_has_exchangemargin() {
  _has_bits_[0] |= 0x08000000u;
}
inline void MThostFtdcTradingAccountField::clear_has_exchangemargin() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void MThostFtdcTradingAccountField::clear_exchangemargin() {
  exchangemargin_ = 0;
  clear_has_exchangemargin();
}
inline double MThostFtdcTradingAccountField::exchangemargin() const {
  return exchangemargin_;
}
inline void MThostFtdcTradingAccountField::set_exchangemargin(double value) {
  set_has_exchangemargin();
  exchangemargin_ = value;
}

// -------------------------------------------------------------------

// MThostFtdcQryTradingAccountField

// required string BrokerID = 1;
inline bool MThostFtdcQryTradingAccountField::has_brokerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MThostFtdcQryTradingAccountField::set_has_brokerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MThostFtdcQryTradingAccountField::clear_has_brokerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MThostFtdcQryTradingAccountField::clear_brokerid() {
  if (brokerid_ != &::google::protobuf::internal::kEmptyString) {
    brokerid_->clear();
  }
  clear_has_brokerid();
}
inline const ::std::string& MThostFtdcQryTradingAccountField::brokerid() const {
  return *brokerid_;
}
inline void MThostFtdcQryTradingAccountField::set_brokerid(const ::std::string& value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void MThostFtdcQryTradingAccountField::set_brokerid(const char* value) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(value);
}
inline void MThostFtdcQryTradingAccountField::set_brokerid(const char* value, size_t size) {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  brokerid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcQryTradingAccountField::mutable_brokerid() {
  set_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    brokerid_ = new ::std::string;
  }
  return brokerid_;
}
inline ::std::string* MThostFtdcQryTradingAccountField::release_brokerid() {
  clear_has_brokerid();
  if (brokerid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = brokerid_;
    brokerid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string InvestorID = 2;
inline bool MThostFtdcQryTradingAccountField::has_investorid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MThostFtdcQryTradingAccountField::set_has_investorid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MThostFtdcQryTradingAccountField::clear_has_investorid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MThostFtdcQryTradingAccountField::clear_investorid() {
  if (investorid_ != &::google::protobuf::internal::kEmptyString) {
    investorid_->clear();
  }
  clear_has_investorid();
}
inline const ::std::string& MThostFtdcQryTradingAccountField::investorid() const {
  return *investorid_;
}
inline void MThostFtdcQryTradingAccountField::set_investorid(const ::std::string& value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void MThostFtdcQryTradingAccountField::set_investorid(const char* value) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(value);
}
inline void MThostFtdcQryTradingAccountField::set_investorid(const char* value, size_t size) {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  investorid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcQryTradingAccountField::mutable_investorid() {
  set_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    investorid_ = new ::std::string;
  }
  return investorid_;
}
inline ::std::string* MThostFtdcQryTradingAccountField::release_investorid() {
  clear_has_investorid();
  if (investorid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = investorid_;
    investorid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ConRequest

// required int32 QueType = 1;
inline bool ConRequest::has_quetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConRequest::set_has_quetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConRequest::clear_has_quetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConRequest::clear_quetype() {
  quetype_ = 0;
  clear_has_quetype();
}
inline ::google::protobuf::int32 ConRequest::quetype() const {
  return quetype_;
}
inline void ConRequest::set_quetype(::google::protobuf::int32 value) {
  set_has_quetype();
  quetype_ = value;
}

// required string ContractList = 2;
inline bool ConRequest::has_contractlist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConRequest::set_has_contractlist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConRequest::clear_has_contractlist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConRequest::clear_contractlist() {
  if (contractlist_ != &::google::protobuf::internal::kEmptyString) {
    contractlist_->clear();
  }
  clear_has_contractlist();
}
inline const ::std::string& ConRequest::contractlist() const {
  return *contractlist_;
}
inline void ConRequest::set_contractlist(const ::std::string& value) {
  set_has_contractlist();
  if (contractlist_ == &::google::protobuf::internal::kEmptyString) {
    contractlist_ = new ::std::string;
  }
  contractlist_->assign(value);
}
inline void ConRequest::set_contractlist(const char* value) {
  set_has_contractlist();
  if (contractlist_ == &::google::protobuf::internal::kEmptyString) {
    contractlist_ = new ::std::string;
  }
  contractlist_->assign(value);
}
inline void ConRequest::set_contractlist(const char* value, size_t size) {
  set_has_contractlist();
  if (contractlist_ == &::google::protobuf::internal::kEmptyString) {
    contractlist_ = new ::std::string;
  }
  contractlist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConRequest::mutable_contractlist() {
  set_has_contractlist();
  if (contractlist_ == &::google::protobuf::internal::kEmptyString) {
    contractlist_ = new ::std::string;
  }
  return contractlist_;
}
inline ::std::string* ConRequest::release_contractlist() {
  clear_has_contractlist();
  if (contractlist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contractlist_;
    contractlist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// ConResponse

// required int32 TimeStamp = 1;
inline bool ConResponse::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConResponse::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConResponse::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConResponse::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline ::google::protobuf::int32 ConResponse::timestamp() const {
  return timestamp_;
}
inline void ConResponse::set_timestamp(::google::protobuf::int32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// repeated .FutureTradingPB.MThostFtdcInstrumentField ContractList = 2;
inline int ConResponse::contractlist_size() const {
  return contractlist_.size();
}
inline void ConResponse::clear_contractlist() {
  contractlist_.Clear();
}
inline const ::FutureTradingPB::MThostFtdcInstrumentField& ConResponse::contractlist(int index) const {
  return contractlist_.Get(index);
}
inline ::FutureTradingPB::MThostFtdcInstrumentField* ConResponse::mutable_contractlist(int index) {
  return contractlist_.Mutable(index);
}
inline ::FutureTradingPB::MThostFtdcInstrumentField* ConResponse::add_contractlist() {
  return contractlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInstrumentField >&
ConResponse::contractlist() const {
  return contractlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::FutureTradingPB::MThostFtdcInstrumentField >*
ConResponse::mutable_contractlist() {
  return &contractlist_;
}

// -------------------------------------------------------------------

// MThostFtdcInstrumentField

// required string InstrumentID = 1;
inline bool MThostFtdcInstrumentField::has_instrumentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_instrumentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MThostFtdcInstrumentField::clear_has_instrumentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MThostFtdcInstrumentField::clear_instrumentid() {
  if (instrumentid_ != &::google::protobuf::internal::kEmptyString) {
    instrumentid_->clear();
  }
  clear_has_instrumentid();
}
inline const ::std::string& MThostFtdcInstrumentField::instrumentid() const {
  return *instrumentid_;
}
inline void MThostFtdcInstrumentField::set_instrumentid(const ::std::string& value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_instrumentid(const char* value) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_instrumentid(const char* value, size_t size) {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  instrumentid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_instrumentid() {
  set_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    instrumentid_ = new ::std::string;
  }
  return instrumentid_;
}
inline ::std::string* MThostFtdcInstrumentField::release_instrumentid() {
  clear_has_instrumentid();
  if (instrumentid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentid_;
    instrumentid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeID = 2;
inline bool MThostFtdcInstrumentField::has_exchangeid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_exchangeid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MThostFtdcInstrumentField::clear_has_exchangeid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MThostFtdcInstrumentField::clear_exchangeid() {
  if (exchangeid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeid_->clear();
  }
  clear_has_exchangeid();
}
inline const ::std::string& MThostFtdcInstrumentField::exchangeid() const {
  return *exchangeid_;
}
inline void MThostFtdcInstrumentField::set_exchangeid(const ::std::string& value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_exchangeid(const char* value) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_exchangeid(const char* value, size_t size) {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  exchangeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_exchangeid() {
  set_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeid_ = new ::std::string;
  }
  return exchangeid_;
}
inline ::std::string* MThostFtdcInstrumentField::release_exchangeid() {
  clear_has_exchangeid();
  if (exchangeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeid_;
    exchangeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string InstrumentName = 3;
inline bool MThostFtdcInstrumentField::has_instrumentname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_instrumentname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MThostFtdcInstrumentField::clear_has_instrumentname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MThostFtdcInstrumentField::clear_instrumentname() {
  if (instrumentname_ != &::google::protobuf::internal::kEmptyString) {
    instrumentname_->clear();
  }
  clear_has_instrumentname();
}
inline const ::std::string& MThostFtdcInstrumentField::instrumentname() const {
  return *instrumentname_;
}
inline void MThostFtdcInstrumentField::set_instrumentname(const ::std::string& value) {
  set_has_instrumentname();
  if (instrumentname_ == &::google::protobuf::internal::kEmptyString) {
    instrumentname_ = new ::std::string;
  }
  instrumentname_->assign(value);
}
inline void MThostFtdcInstrumentField::set_instrumentname(const char* value) {
  set_has_instrumentname();
  if (instrumentname_ == &::google::protobuf::internal::kEmptyString) {
    instrumentname_ = new ::std::string;
  }
  instrumentname_->assign(value);
}
inline void MThostFtdcInstrumentField::set_instrumentname(const char* value, size_t size) {
  set_has_instrumentname();
  if (instrumentname_ == &::google::protobuf::internal::kEmptyString) {
    instrumentname_ = new ::std::string;
  }
  instrumentname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_instrumentname() {
  set_has_instrumentname();
  if (instrumentname_ == &::google::protobuf::internal::kEmptyString) {
    instrumentname_ = new ::std::string;
  }
  return instrumentname_;
}
inline ::std::string* MThostFtdcInstrumentField::release_instrumentname() {
  clear_has_instrumentname();
  if (instrumentname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrumentname_;
    instrumentname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExchangeInstID = 4;
inline bool MThostFtdcInstrumentField::has_exchangeinstid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_exchangeinstid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MThostFtdcInstrumentField::clear_has_exchangeinstid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MThostFtdcInstrumentField::clear_exchangeinstid() {
  if (exchangeinstid_ != &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_->clear();
  }
  clear_has_exchangeinstid();
}
inline const ::std::string& MThostFtdcInstrumentField::exchangeinstid() const {
  return *exchangeinstid_;
}
inline void MThostFtdcInstrumentField::set_exchangeinstid(const ::std::string& value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_exchangeinstid(const char* value) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_exchangeinstid(const char* value, size_t size) {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  exchangeinstid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_exchangeinstid() {
  set_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    exchangeinstid_ = new ::std::string;
  }
  return exchangeinstid_;
}
inline ::std::string* MThostFtdcInstrumentField::release_exchangeinstid() {
  clear_has_exchangeinstid();
  if (exchangeinstid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exchangeinstid_;
    exchangeinstid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ProductID = 5;
inline bool MThostFtdcInstrumentField::has_productid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_productid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MThostFtdcInstrumentField::clear_has_productid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MThostFtdcInstrumentField::clear_productid() {
  if (productid_ != &::google::protobuf::internal::kEmptyString) {
    productid_->clear();
  }
  clear_has_productid();
}
inline const ::std::string& MThostFtdcInstrumentField::productid() const {
  return *productid_;
}
inline void MThostFtdcInstrumentField::set_productid(const ::std::string& value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_productid(const char* value) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(value);
}
inline void MThostFtdcInstrumentField::set_productid(const char* value, size_t size) {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  productid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_productid() {
  set_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    productid_ = new ::std::string;
  }
  return productid_;
}
inline ::std::string* MThostFtdcInstrumentField::release_productid() {
  clear_has_productid();
  if (productid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productid_;
    productid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ProductClass = 6;
inline bool MThostFtdcInstrumentField::has_productclass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_productclass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MThostFtdcInstrumentField::clear_has_productclass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MThostFtdcInstrumentField::clear_productclass() {
  if (productclass_ != &::google::protobuf::internal::kEmptyString) {
    productclass_->clear();
  }
  clear_has_productclass();
}
inline const ::std::string& MThostFtdcInstrumentField::productclass() const {
  return *productclass_;
}
inline void MThostFtdcInstrumentField::set_productclass(const ::std::string& value) {
  set_has_productclass();
  if (productclass_ == &::google::protobuf::internal::kEmptyString) {
    productclass_ = new ::std::string;
  }
  productclass_->assign(value);
}
inline void MThostFtdcInstrumentField::set_productclass(const char* value) {
  set_has_productclass();
  if (productclass_ == &::google::protobuf::internal::kEmptyString) {
    productclass_ = new ::std::string;
  }
  productclass_->assign(value);
}
inline void MThostFtdcInstrumentField::set_productclass(const char* value, size_t size) {
  set_has_productclass();
  if (productclass_ == &::google::protobuf::internal::kEmptyString) {
    productclass_ = new ::std::string;
  }
  productclass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_productclass() {
  set_has_productclass();
  if (productclass_ == &::google::protobuf::internal::kEmptyString) {
    productclass_ = new ::std::string;
  }
  return productclass_;
}
inline ::std::string* MThostFtdcInstrumentField::release_productclass() {
  clear_has_productclass();
  if (productclass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = productclass_;
    productclass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 DeliveryYear = 7;
inline bool MThostFtdcInstrumentField::has_deliveryyear() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_deliveryyear() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MThostFtdcInstrumentField::clear_has_deliveryyear() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MThostFtdcInstrumentField::clear_deliveryyear() {
  deliveryyear_ = 0;
  clear_has_deliveryyear();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::deliveryyear() const {
  return deliveryyear_;
}
inline void MThostFtdcInstrumentField::set_deliveryyear(::google::protobuf::int32 value) {
  set_has_deliveryyear();
  deliveryyear_ = value;
}

// required int32 DeliveryMonth = 8;
inline bool MThostFtdcInstrumentField::has_deliverymonth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_deliverymonth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MThostFtdcInstrumentField::clear_has_deliverymonth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MThostFtdcInstrumentField::clear_deliverymonth() {
  deliverymonth_ = 0;
  clear_has_deliverymonth();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::deliverymonth() const {
  return deliverymonth_;
}
inline void MThostFtdcInstrumentField::set_deliverymonth(::google::protobuf::int32 value) {
  set_has_deliverymonth();
  deliverymonth_ = value;
}

// required int32 MaxMarketOrderVolume = 9;
inline bool MThostFtdcInstrumentField::has_maxmarketordervolume() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_maxmarketordervolume() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MThostFtdcInstrumentField::clear_has_maxmarketordervolume() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MThostFtdcInstrumentField::clear_maxmarketordervolume() {
  maxmarketordervolume_ = 0;
  clear_has_maxmarketordervolume();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::maxmarketordervolume() const {
  return maxmarketordervolume_;
}
inline void MThostFtdcInstrumentField::set_maxmarketordervolume(::google::protobuf::int32 value) {
  set_has_maxmarketordervolume();
  maxmarketordervolume_ = value;
}

// required int32 MinMarketOrderVolume = 10;
inline bool MThostFtdcInstrumentField::has_minmarketordervolume() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_minmarketordervolume() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MThostFtdcInstrumentField::clear_has_minmarketordervolume() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MThostFtdcInstrumentField::clear_minmarketordervolume() {
  minmarketordervolume_ = 0;
  clear_has_minmarketordervolume();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::minmarketordervolume() const {
  return minmarketordervolume_;
}
inline void MThostFtdcInstrumentField::set_minmarketordervolume(::google::protobuf::int32 value) {
  set_has_minmarketordervolume();
  minmarketordervolume_ = value;
}

// required int32 MaxLimitOrderVolume = 11;
inline bool MThostFtdcInstrumentField::has_maxlimitordervolume() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_maxlimitordervolume() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MThostFtdcInstrumentField::clear_has_maxlimitordervolume() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MThostFtdcInstrumentField::clear_maxlimitordervolume() {
  maxlimitordervolume_ = 0;
  clear_has_maxlimitordervolume();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::maxlimitordervolume() const {
  return maxlimitordervolume_;
}
inline void MThostFtdcInstrumentField::set_maxlimitordervolume(::google::protobuf::int32 value) {
  set_has_maxlimitordervolume();
  maxlimitordervolume_ = value;
}

// required int32 MinLimitOrderVolume = 12;
inline bool MThostFtdcInstrumentField::has_minlimitordervolume() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_minlimitordervolume() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MThostFtdcInstrumentField::clear_has_minlimitordervolume() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MThostFtdcInstrumentField::clear_minlimitordervolume() {
  minlimitordervolume_ = 0;
  clear_has_minlimitordervolume();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::minlimitordervolume() const {
  return minlimitordervolume_;
}
inline void MThostFtdcInstrumentField::set_minlimitordervolume(::google::protobuf::int32 value) {
  set_has_minlimitordervolume();
  minlimitordervolume_ = value;
}

// required int32 VolumeMultiple = 13;
inline bool MThostFtdcInstrumentField::has_volumemultiple() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_volumemultiple() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MThostFtdcInstrumentField::clear_has_volumemultiple() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MThostFtdcInstrumentField::clear_volumemultiple() {
  volumemultiple_ = 0;
  clear_has_volumemultiple();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::volumemultiple() const {
  return volumemultiple_;
}
inline void MThostFtdcInstrumentField::set_volumemultiple(::google::protobuf::int32 value) {
  set_has_volumemultiple();
  volumemultiple_ = value;
}

// required double PriceTick = 14;
inline bool MThostFtdcInstrumentField::has_pricetick() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_pricetick() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MThostFtdcInstrumentField::clear_has_pricetick() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MThostFtdcInstrumentField::clear_pricetick() {
  pricetick_ = 0;
  clear_has_pricetick();
}
inline double MThostFtdcInstrumentField::pricetick() const {
  return pricetick_;
}
inline void MThostFtdcInstrumentField::set_pricetick(double value) {
  set_has_pricetick();
  pricetick_ = value;
}

// required string CreateDate = 15;
inline bool MThostFtdcInstrumentField::has_createdate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_createdate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MThostFtdcInstrumentField::clear_has_createdate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MThostFtdcInstrumentField::clear_createdate() {
  if (createdate_ != &::google::protobuf::internal::kEmptyString) {
    createdate_->clear();
  }
  clear_has_createdate();
}
inline const ::std::string& MThostFtdcInstrumentField::createdate() const {
  return *createdate_;
}
inline void MThostFtdcInstrumentField::set_createdate(const ::std::string& value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_createdate(const char* value) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_createdate(const char* value, size_t size) {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  createdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_createdate() {
  set_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    createdate_ = new ::std::string;
  }
  return createdate_;
}
inline ::std::string* MThostFtdcInstrumentField::release_createdate() {
  clear_has_createdate();
  if (createdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createdate_;
    createdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string OpenDate = 16;
inline bool MThostFtdcInstrumentField::has_opendate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_opendate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MThostFtdcInstrumentField::clear_has_opendate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MThostFtdcInstrumentField::clear_opendate() {
  if (opendate_ != &::google::protobuf::internal::kEmptyString) {
    opendate_->clear();
  }
  clear_has_opendate();
}
inline const ::std::string& MThostFtdcInstrumentField::opendate() const {
  return *opendate_;
}
inline void MThostFtdcInstrumentField::set_opendate(const ::std::string& value) {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  opendate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_opendate(const char* value) {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  opendate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_opendate(const char* value, size_t size) {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  opendate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_opendate() {
  set_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    opendate_ = new ::std::string;
  }
  return opendate_;
}
inline ::std::string* MThostFtdcInstrumentField::release_opendate() {
  clear_has_opendate();
  if (opendate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opendate_;
    opendate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string ExpireDate = 17;
inline bool MThostFtdcInstrumentField::has_expiredate() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_expiredate() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MThostFtdcInstrumentField::clear_has_expiredate() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MThostFtdcInstrumentField::clear_expiredate() {
  if (expiredate_ != &::google::protobuf::internal::kEmptyString) {
    expiredate_->clear();
  }
  clear_has_expiredate();
}
inline const ::std::string& MThostFtdcInstrumentField::expiredate() const {
  return *expiredate_;
}
inline void MThostFtdcInstrumentField::set_expiredate(const ::std::string& value) {
  set_has_expiredate();
  if (expiredate_ == &::google::protobuf::internal::kEmptyString) {
    expiredate_ = new ::std::string;
  }
  expiredate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_expiredate(const char* value) {
  set_has_expiredate();
  if (expiredate_ == &::google::protobuf::internal::kEmptyString) {
    expiredate_ = new ::std::string;
  }
  expiredate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_expiredate(const char* value, size_t size) {
  set_has_expiredate();
  if (expiredate_ == &::google::protobuf::internal::kEmptyString) {
    expiredate_ = new ::std::string;
  }
  expiredate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_expiredate() {
  set_has_expiredate();
  if (expiredate_ == &::google::protobuf::internal::kEmptyString) {
    expiredate_ = new ::std::string;
  }
  return expiredate_;
}
inline ::std::string* MThostFtdcInstrumentField::release_expiredate() {
  clear_has_expiredate();
  if (expiredate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = expiredate_;
    expiredate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string StartDelivDate = 18;
inline bool MThostFtdcInstrumentField::has_startdelivdate() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_startdelivdate() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MThostFtdcInstrumentField::clear_has_startdelivdate() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MThostFtdcInstrumentField::clear_startdelivdate() {
  if (startdelivdate_ != &::google::protobuf::internal::kEmptyString) {
    startdelivdate_->clear();
  }
  clear_has_startdelivdate();
}
inline const ::std::string& MThostFtdcInstrumentField::startdelivdate() const {
  return *startdelivdate_;
}
inline void MThostFtdcInstrumentField::set_startdelivdate(const ::std::string& value) {
  set_has_startdelivdate();
  if (startdelivdate_ == &::google::protobuf::internal::kEmptyString) {
    startdelivdate_ = new ::std::string;
  }
  startdelivdate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_startdelivdate(const char* value) {
  set_has_startdelivdate();
  if (startdelivdate_ == &::google::protobuf::internal::kEmptyString) {
    startdelivdate_ = new ::std::string;
  }
  startdelivdate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_startdelivdate(const char* value, size_t size) {
  set_has_startdelivdate();
  if (startdelivdate_ == &::google::protobuf::internal::kEmptyString) {
    startdelivdate_ = new ::std::string;
  }
  startdelivdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_startdelivdate() {
  set_has_startdelivdate();
  if (startdelivdate_ == &::google::protobuf::internal::kEmptyString) {
    startdelivdate_ = new ::std::string;
  }
  return startdelivdate_;
}
inline ::std::string* MThostFtdcInstrumentField::release_startdelivdate() {
  clear_has_startdelivdate();
  if (startdelivdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startdelivdate_;
    startdelivdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string EndDelivDate = 19;
inline bool MThostFtdcInstrumentField::has_enddelivdate() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_enddelivdate() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MThostFtdcInstrumentField::clear_has_enddelivdate() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MThostFtdcInstrumentField::clear_enddelivdate() {
  if (enddelivdate_ != &::google::protobuf::internal::kEmptyString) {
    enddelivdate_->clear();
  }
  clear_has_enddelivdate();
}
inline const ::std::string& MThostFtdcInstrumentField::enddelivdate() const {
  return *enddelivdate_;
}
inline void MThostFtdcInstrumentField::set_enddelivdate(const ::std::string& value) {
  set_has_enddelivdate();
  if (enddelivdate_ == &::google::protobuf::internal::kEmptyString) {
    enddelivdate_ = new ::std::string;
  }
  enddelivdate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_enddelivdate(const char* value) {
  set_has_enddelivdate();
  if (enddelivdate_ == &::google::protobuf::internal::kEmptyString) {
    enddelivdate_ = new ::std::string;
  }
  enddelivdate_->assign(value);
}
inline void MThostFtdcInstrumentField::set_enddelivdate(const char* value, size_t size) {
  set_has_enddelivdate();
  if (enddelivdate_ == &::google::protobuf::internal::kEmptyString) {
    enddelivdate_ = new ::std::string;
  }
  enddelivdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_enddelivdate() {
  set_has_enddelivdate();
  if (enddelivdate_ == &::google::protobuf::internal::kEmptyString) {
    enddelivdate_ = new ::std::string;
  }
  return enddelivdate_;
}
inline ::std::string* MThostFtdcInstrumentField::release_enddelivdate() {
  clear_has_enddelivdate();
  if (enddelivdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enddelivdate_;
    enddelivdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string InstLifePhase = 20;
inline bool MThostFtdcInstrumentField::has_instlifephase() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_instlifephase() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MThostFtdcInstrumentField::clear_has_instlifephase() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MThostFtdcInstrumentField::clear_instlifephase() {
  if (instlifephase_ != &::google::protobuf::internal::kEmptyString) {
    instlifephase_->clear();
  }
  clear_has_instlifephase();
}
inline const ::std::string& MThostFtdcInstrumentField::instlifephase() const {
  return *instlifephase_;
}
inline void MThostFtdcInstrumentField::set_instlifephase(const ::std::string& value) {
  set_has_instlifephase();
  if (instlifephase_ == &::google::protobuf::internal::kEmptyString) {
    instlifephase_ = new ::std::string;
  }
  instlifephase_->assign(value);
}
inline void MThostFtdcInstrumentField::set_instlifephase(const char* value) {
  set_has_instlifephase();
  if (instlifephase_ == &::google::protobuf::internal::kEmptyString) {
    instlifephase_ = new ::std::string;
  }
  instlifephase_->assign(value);
}
inline void MThostFtdcInstrumentField::set_instlifephase(const char* value, size_t size) {
  set_has_instlifephase();
  if (instlifephase_ == &::google::protobuf::internal::kEmptyString) {
    instlifephase_ = new ::std::string;
  }
  instlifephase_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_instlifephase() {
  set_has_instlifephase();
  if (instlifephase_ == &::google::protobuf::internal::kEmptyString) {
    instlifephase_ = new ::std::string;
  }
  return instlifephase_;
}
inline ::std::string* MThostFtdcInstrumentField::release_instlifephase() {
  clear_has_instlifephase();
  if (instlifephase_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instlifephase_;
    instlifephase_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 IsTrading = 21;
inline bool MThostFtdcInstrumentField::has_istrading() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_istrading() {
  _has_bits_[0] |= 0x00100000u;
}
inline void MThostFtdcInstrumentField::clear_has_istrading() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void MThostFtdcInstrumentField::clear_istrading() {
  istrading_ = 0;
  clear_has_istrading();
}
inline ::google::protobuf::int32 MThostFtdcInstrumentField::istrading() const {
  return istrading_;
}
inline void MThostFtdcInstrumentField::set_istrading(::google::protobuf::int32 value) {
  set_has_istrading();
  istrading_ = value;
}

// required string PositionType = 22;
inline bool MThostFtdcInstrumentField::has_positiontype() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_positiontype() {
  _has_bits_[0] |= 0x00200000u;
}
inline void MThostFtdcInstrumentField::clear_has_positiontype() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void MThostFtdcInstrumentField::clear_positiontype() {
  if (positiontype_ != &::google::protobuf::internal::kEmptyString) {
    positiontype_->clear();
  }
  clear_has_positiontype();
}
inline const ::std::string& MThostFtdcInstrumentField::positiontype() const {
  return *positiontype_;
}
inline void MThostFtdcInstrumentField::set_positiontype(const ::std::string& value) {
  set_has_positiontype();
  if (positiontype_ == &::google::protobuf::internal::kEmptyString) {
    positiontype_ = new ::std::string;
  }
  positiontype_->assign(value);
}
inline void MThostFtdcInstrumentField::set_positiontype(const char* value) {
  set_has_positiontype();
  if (positiontype_ == &::google::protobuf::internal::kEmptyString) {
    positiontype_ = new ::std::string;
  }
  positiontype_->assign(value);
}
inline void MThostFtdcInstrumentField::set_positiontype(const char* value, size_t size) {
  set_has_positiontype();
  if (positiontype_ == &::google::protobuf::internal::kEmptyString) {
    positiontype_ = new ::std::string;
  }
  positiontype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_positiontype() {
  set_has_positiontype();
  if (positiontype_ == &::google::protobuf::internal::kEmptyString) {
    positiontype_ = new ::std::string;
  }
  return positiontype_;
}
inline ::std::string* MThostFtdcInstrumentField::release_positiontype() {
  clear_has_positiontype();
  if (positiontype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positiontype_;
    positiontype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string PositionDateType = 23;
inline bool MThostFtdcInstrumentField::has_positiondatetype() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_positiondatetype() {
  _has_bits_[0] |= 0x00400000u;
}
inline void MThostFtdcInstrumentField::clear_has_positiondatetype() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void MThostFtdcInstrumentField::clear_positiondatetype() {
  if (positiondatetype_ != &::google::protobuf::internal::kEmptyString) {
    positiondatetype_->clear();
  }
  clear_has_positiondatetype();
}
inline const ::std::string& MThostFtdcInstrumentField::positiondatetype() const {
  return *positiondatetype_;
}
inline void MThostFtdcInstrumentField::set_positiondatetype(const ::std::string& value) {
  set_has_positiondatetype();
  if (positiondatetype_ == &::google::protobuf::internal::kEmptyString) {
    positiondatetype_ = new ::std::string;
  }
  positiondatetype_->assign(value);
}
inline void MThostFtdcInstrumentField::set_positiondatetype(const char* value) {
  set_has_positiondatetype();
  if (positiondatetype_ == &::google::protobuf::internal::kEmptyString) {
    positiondatetype_ = new ::std::string;
  }
  positiondatetype_->assign(value);
}
inline void MThostFtdcInstrumentField::set_positiondatetype(const char* value, size_t size) {
  set_has_positiondatetype();
  if (positiondatetype_ == &::google::protobuf::internal::kEmptyString) {
    positiondatetype_ = new ::std::string;
  }
  positiondatetype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MThostFtdcInstrumentField::mutable_positiondatetype() {
  set_has_positiondatetype();
  if (positiondatetype_ == &::google::protobuf::internal::kEmptyString) {
    positiondatetype_ = new ::std::string;
  }
  return positiondatetype_;
}
inline ::std::string* MThostFtdcInstrumentField::release_positiondatetype() {
  clear_has_positiondatetype();
  if (positiondatetype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = positiondatetype_;
    positiondatetype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required double LongMarginRatio = 24;
inline bool MThostFtdcInstrumentField::has_longmarginratio() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_longmarginratio() {
  _has_bits_[0] |= 0x00800000u;
}
inline void MThostFtdcInstrumentField::clear_has_longmarginratio() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void MThostFtdcInstrumentField::clear_longmarginratio() {
  longmarginratio_ = 0;
  clear_has_longmarginratio();
}
inline double MThostFtdcInstrumentField::longmarginratio() const {
  return longmarginratio_;
}
inline void MThostFtdcInstrumentField::set_longmarginratio(double value) {
  set_has_longmarginratio();
  longmarginratio_ = value;
}

// required double ShortMarginRatio = 25;
inline bool MThostFtdcInstrumentField::has_shortmarginratio() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void MThostFtdcInstrumentField::set_has_shortmarginratio() {
  _has_bits_[0] |= 0x01000000u;
}
inline void MThostFtdcInstrumentField::clear_has_shortmarginratio() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void MThostFtdcInstrumentField::clear_shortmarginratio() {
  shortmarginratio_ = 0;
  clear_has_shortmarginratio();
}
inline double MThostFtdcInstrumentField::shortmarginratio() const {
  return shortmarginratio_;
}
inline void MThostFtdcInstrumentField::set_shortmarginratio(double value) {
  set_has_shortmarginratio();
  shortmarginratio_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace FutureTradingPB

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_FutureTrading_2eproto__INCLUDED
